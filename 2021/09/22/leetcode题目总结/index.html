<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>leetcode题目总结 | slowsail'space</title><meta name="keywords" content="题解"><meta name="author" content="slowsail"><meta name="copyright" content="slowsail"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="每次做题需要检查一下的问题：1.字母拼写。看看写着写着变量名是不是写偏了。 2.while循环 for循环 还有链表里面有没有移动，循环是否可以结束。 3.如果函数的参数比较多的话，检查下函数参数有没有填对，仔细想想。 N皇后问题详解具体的思考思路如下： 1.数据结构的选择： ​    选用什么数据结构可以模拟出一个棋盘。联想到Z型字符串，似乎对于这种问题，利用StringBuilder的list">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode题目总结">
<meta property="og:url" content="https://slowsail.top/2021/09/22/leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="slowsail&#39;space">
<meta property="og:description" content="每次做题需要检查一下的问题：1.字母拼写。看看写着写着变量名是不是写偏了。 2.while循环 for循环 还有链表里面有没有移动，循环是否可以结束。 3.如果函数的参数比较多的话，检查下函数参数有没有填对，仔细想想。 N皇后问题详解具体的思考思路如下： 1.数据结构的选择： ​    选用什么数据结构可以模拟出一个棋盘。联想到Z型字符串，似乎对于这种问题，利用StringBuilder的list">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://slowsail.top/img/6.png">
<meta property="article:published_time" content="2021-09-22T12:36:22.000Z">
<meta property="article:modified_time" content="2022-09-07T12:59:42.617Z">
<meta property="article:author" content="slowsail">
<meta property="article:tag" content="题解">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://slowsail.top/img/6.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://slowsail.top/2021/09/22/leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'leetcode题目总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-07 20:59:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 存档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/6.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">slowsail'space</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 存档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">leetcode题目总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-22T12:36:22.000Z" title="发表于 2021-09-22 20:36:22">2021-09-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-07T12:59:42.617Z" title="更新于 2022-09-07 20:59:42">2022-09-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="leetcode题目总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="每次做题需要检查一下的问题："><a href="#每次做题需要检查一下的问题：" class="headerlink" title="每次做题需要检查一下的问题："></a>每次做题需要检查一下的问题：</h4><p>1.字母拼写。看看写着写着变量名是不是写偏了。</p>
<p>2.while循环 for循环 还有链表里面有没有移动，循环是否可以结束。</p>
<p>3.如果函数的参数比较多的话，检查下函数参数有没有填对，仔细想想。</p>
<h4 id="N皇后问题详解"><a href="#N皇后问题详解" class="headerlink" title="N皇后问题详解"></a>N皇后问题详解</h4><p>具体的思考思路如下：</p>
<p>1.数据结构的选择：</p>
<p>​    选用什么数据结构可以模拟出一个棋盘。联想到Z型字符串，似乎对于这种问题，利用StringBuilder的list可以用来模拟一个字符串二维序列。</p>
<p>​    为了解决这个问题，我们应当从一个空棋盘开始回溯：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		List&lt;List&lt;String&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    	List&lt;StringBuilder&gt; board=<span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//选取StringBuilder的list作为一个二维字符串序列的容器</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            board.add(sb);</span><br><span class="line">        &#125;<span class="comment">//初始化空棋盘</span></span><br><span class="line">    	backTrack(res,board,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;<span class="comment">//记得返回答案</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2.怎么回溯？</p>
<p>回溯其实要解决如下的几个问题，或者说回溯可以问几个问题来引导自己的思路：</p>
<p>​    1.什么时候终结自己的回溯，回溯每次改变的量是什么，回溯每次不变的行为是什么？</p>
<p>​        回溯的终点应该是当最后一行的皇后都已经被选定，这个时候回溯达到终点。</p>
<p>​        因此，回溯每次都要改变自己做选择的行数。</p>
<p>​        对于每一行，每次都要做的行为是选取一列，保证该列的前提下，然后选取一个皇后。做完选择后，继续到下一行做选择。</p>
<p>​        </p>
<p>​        <strong>注意：做完回溯之后的回退，这个多做几题就知道了。</strong></p>
<p>因此可以写出下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; res,List&lt;StringBuilder&gt; board,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size=board.size();</span><br><span class="line">    <span class="keyword">if</span>(depth==board.size())&#123;</span><br><span class="line">        List&lt;String&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(StringBuilder row:board)&#123;</span><br><span class="line">            ans.add(row.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isValid(board,depth,i))<span class="keyword">continue</span>;</span><br><span class="line">        board.get(depth).setCharAt(i,<span class="string">&#x27;Q&#x27;</span>);<span class="comment">//注意这个api，自己没有记住</span></span><br><span class="line">        backTrack(res,board,depth+<span class="number">1</span>);</span><br><span class="line">        board.get(depth).setCharAt(i,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.根据题目写有效性的判断：</p>
<p>对于同一行只有一个皇后，已经在回溯中写了。</p>
<p>要判断对角线和同一列的。注意，都只需要判断上方即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(List&lt;StringBuilder&gt; board,<span class="keyword">int</span> row,<span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size=board.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.get(i).charAt(col)==<span class="string">&#x27;Q&#x27;</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=row-<span class="number">1</span>,j=col-<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j--)&#123;<span class="comment">//千万要注意一下，这里的终止判断条件语句要用&amp;&amp;连接，自己之前之前直接用,连接了，低级错误</span></span><br><span class="line">        <span class="keyword">if</span>(board.get(i).charAt(j)==<span class="string">&#x27;Q&#x27;</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=row-<span class="number">1</span>,j=col+<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&lt;size;i--,j++)&#123; <span class="comment">//这个for循环里面的变量加减问题自己已经出现过多次错误了，自己一定要小心</span></span><br><span class="line">        <span class="keyword">if</span>(board.get(i).charAt(j)==<span class="string">&#x27;Q&#x27;</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h4><p>依然是问自己几个问题：</p>
<p>1.回溯的终点在哪里？如何回溯？</p>
<p>这里一个重要的问题就是，回溯每次做的选择是什么，可能的选择是什么。</p>
<p>这里回溯的终点为当最后一个位置都已经确定的时候，即</p>
<p>depth==n的时候就可以返回一个答案了。</p>
<p>对于其中每一个位置，都有选或者不选两个选项，因此与普通回溯的for循环不同，就是一个push和一个pop的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span>[]nums,<span class="keyword">int</span> depth,List&lt;List&lt;Integer&gt; res,Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=num.length;</span><br><span class="line">    <span class="keyword">if</span>(depth==len)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    path.push(nums[depth]);</span><br><span class="line">    backTrack(nums,depth+<span class="number">1</span>,res,path);</span><br><span class="line">    path.pop(nums[depth]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明一下，Deque的实现类型最好用ArrayDeque。</p>
<h4 id="组合总和问题"><a href="#组合总和问题" class="headerlink" title="组合总和问题"></a>组合总和问题</h4><p>这道题我一开始没有看出来是使用回溯，所以想一想回溯应用的场景：</p>
<p>1.<strong>寻找所有可行解的问题，其本质是暴力查询，也就是回溯。</strong></p>
<p>因此这道题应该是可以意识到要用回溯的。</p>
<p>依然问问回溯的问题：</p>
<p>回溯的终点在哪里，我们每次做什么动作：</p>
<p>​    因为每次目标是凑到target，因此回溯的终点就是达到target或者已经超出了target。于是，在我们的回溯函数中，我们始终用target去减去候选值，当得到结果为负的时候，回溯就结束。</p>
<p>​    每次做的动作就是选出一个数出来，这里要引入一个begin的思路。就是说，由于[1,1,2]和[1,2,1]是一样的，因此我们要利用for循环的方式，来保证我们选数是按照一定顺序的。同时要注意一点，就是我们选数是可以重复的，所以回溯往里面深入的时候，其实是没有量的变化的，我们依靠终结条件来跳出循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; path=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len=candidates.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        backTrack(candidates,target,<span class="number">0</span>,res,path);<span class="comment">//写这种好多参数的函数，一定要检查一下是否和下面的函数对应</span></span><br><span class="line">        <span class="keyword">return</span> res;<span class="comment">//不要忘记返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> depth,List&lt;List&lt;Integer&gt;&gt; res,Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=depth;i&lt;candidates.length;i++)&#123;</span><br><span class="line">        path.addLast(candidates[i]);</span><br><span class="line">        backTrack(candidates,target-candidates[i],i,res,path);<span class="comment">//回溯里这里传递的参量不要不动脑，稍微想一想</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; path=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len=candidates.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTrack(candidates,target,<span class="number">0</span>,res,path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> depth,List&lt;List&lt;Integer&gt;&gt; res,Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=depth;i&lt;candidates.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target-candidates[i]&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        path.addLast(candidates[i]);</span><br><span class="line">        backTrack(candidates,target-candidates[i],i,res,path);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//一个小优化，注意在哪里剪枝---先找到重复的地方</span></span><br></pre></td></tr></table></figure>



<h4 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h4><p>这道题有很多的边界条件，因此需要做考虑。</p>
<p>终点条件非常简单，就是4个整数都选完了。</p>
<p>因此，其实就是有四层，每一层做选择的问题。并且有一个限制条件，就是每一层实际都最多选三个字母。</p>
<p>一些限制条件列举如下：</p>
<p>​    1.如果0开头，该层就要结束。</p>
<p>​    2.每一层内部for循环里面，是上限是depth+3</p>
<p>所以尝试写写backTrack:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> depth,String s,StringBuilder path,List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth==<span class="number">4</span>)&#123;</span><br><span class="line">        res.add(path.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;index+<span class="number">3</span>;i++)&#123;</span><br><span class="line">       <span class="comment">//我自己在写的时候，写到这里卡住了。因为我还是沿袭以前的思路，，但是其实就是要把实际意义给抽象清楚，这次说的其实是截取一个范围。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是不考虑多余情况的一个backTrack：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(begin==len)&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth==<span class="number">4</span>)&#123;</span><br><span class="line">        res.add(String.join(<span class="string">&quot;.&quot;</span>, path));<span class="comment">//记住这个连接的api</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;begin+index;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(judgeIP(begin,i,))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h4><p>这种生成所有可能符合条件的题目，还是应该想到回溯方法。</p>
<p>层数就是退出的条件。而每次做出的选择，就是是否选择)和(。一个小tip是在编程的时候想一想，一次选择的完整过程是怎样的。</p>
<p>如果不考虑说要列举所有的组合，一次过程可能是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">	path.add(&#39;(&#39;);</span><br><span class="line">	&#x2F;&#x2F;中间插入递归</span><br><span class="line">	path.add(&#39;)&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是解回溯问题一定注意的一点是，不要用for循环来推进层数。层数应该是由里面的递归来推进的。</p>
<p>在所有的题目中，<strong>每一层只关注这一层做的事情。</strong>比如这里，添加’(‘和’)’是一层里面的动作，外面就不要添加for循环了。</p>
<p>所以，一层里面的写法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(条件1)&#123;</span><br><span class="line">选择1</span><br><span class="line">递归</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(条件2)&#123;</span><br><span class="line">选择2</span><br><span class="line">递归</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>一定要注意，当一层完成一个决定，那么就应当向下面一层推进这个决定。</strong></p>
<p>这道题的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder path=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        backTrack(n,path,res,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span> n,StringBuilder path,List&lt;String&gt; res,<span class="keyword">int</span> depth,<span class="keyword">int</span> open,<span class="keyword">int</span> close)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(depth==n)&#123;</span><br><span class="line">           res.add(path.toString());</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(open&lt;n)&#123;<span class="comment">//这道题只有两个决定，对于做决定的代码，只要关注这个决定的影响即可。同时，if里面是决定的条件</span></span><br><span class="line">           path.append(<span class="string">&#x27;(&#x27;</span>);<span class="comment">//选择了(,因此准备添加</span></span><br><span class="line">           backTrack(n,path,res,depth,open+<span class="number">1</span>,close);<span class="comment">//推进决定</span></span><br><span class="line">           path.deleteCharAt(path.length()-<span class="number">1</span>);<span class="comment">//记住这个api，deleteCharAt,然后记住path.length()//返回</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(close&lt;open)&#123;</span><br><span class="line">           path.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">           backTrack(n,path,res,depth+<span class="number">1</span>,open,close+<span class="number">1</span>);</span><br><span class="line">           path.deleteCharAt(path.length()-<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>做这种题目，一定记住检查一下递归有没有还原为原来的状态。</p>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></strong></p>
<p>对于此题，出现了重复的数字。其实很容易也更应该想到的，就是先做一个排序。其实对这道题有启发的是三数之和。</p>
<h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h4><p>这道题是栈的应用。</p>
<p>但是关键是要自己可以模拟出逆波兰表达式的解法。</p>
<p>注意代码如何写会比较清晰。</p>
<p>1.如果遇到数字，那么入栈。</p>
<p>2.如果遇到操作符，就将两个数字出栈，然后根据操作符对数字进行运算。将运算的结果入栈。</p>
<p><strong>这里注意审题，tokens是字符串形式</strong></p>
<p>所以代码如下（官方题解）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = tokens.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            String token = tokens[i];</span><br><span class="line">            <span class="keyword">if</span> (isNumber(token)) &#123;</span><br><span class="line">                stack.push(Integer.parseInt(token));<span class="comment">//记住parseInt函数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> num2 = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> num1 = stack.pop();</span><br><span class="line">                <span class="keyword">switch</span> (token) &#123; <span class="comment">//switch case的写法自己也不熟</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        stack.push(num1 + num2);</span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">// 注意这里的break</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        stack.push(num1 - num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        stack.push(num1 * num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        stack.push(num1 / num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(<span class="string">&quot;+&quot;</span>.equals(token) || <span class="string">&quot;-&quot;</span>.equals(token) || <span class="string">&quot;*&quot;</span>.equals(token) || <span class="string">&quot;/&quot;</span>.equals(token));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自己的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=tokens.length;</span><br><span class="line">        Deque&lt;Integer&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            String str=tokens[i];</span><br><span class="line">            <span class="keyword">if</span>(isNum(str))&#123;</span><br><span class="line">                stack.push(Integer.parseInt(str));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> num1=stack.pop();</span><br><span class="line">                <span class="keyword">int</span> num2=stack.pop();</span><br><span class="line">                <span class="keyword">switch</span>(str)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:stack.push(num2-num1);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:stack.push(num2/num1);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:stack.push(num1+num2);<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:stack.push(num1*num2);<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNum</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;*&quot;</span>.equals(str)||<span class="string">&quot;+&quot;</span>.equals(str)||<span class="string">&quot;-&quot;</span>.equals(str)||<span class="string">&quot;/&quot;</span>.equals(str))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h4><p>关键是要明白一个道理，对于第i个房子，可以选择不偷。</p>
<p>动态规划一个要点是明确当前可以做的动作，以及如何正确清晰表现当前可以做的动作。</p>
<h4 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h4><p>1.每个动作的返回值是什么？记录改变值是怎样的？</p>
<p>2.递归的终止是什么？</p>
<p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<p>最大路径和：注意不一定经过根节点。</p>
<p>对于根节点这个点来说，其希望得到的是最大值是</p>
<p>root.val+maxLeft+maxRight。</p>
<p>但是完全可能出现不经过根节点的情况。这个时候最大值可能是left.val+left.left.val+left.right.val。</p>
<p>这里要注意到，maxLeft本质是什么。maxLeft本质是选择放弃掉root.left的边。</p>
<p>所以，每个节点要计算：</p>
<p>​    包含当前节点的最大值–该值和max变量比较</p>
<p>​    当前节点可能的返回值–该值为了计算上层的值</p>
<p>同时要注意到返回值可能为负数，因此要和0做一个比较以舍去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        getMax(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=Math.max(getMax(root.left),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> right=Math.max(getMax(root.right),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>  returnVal=Math.max(root.val+left,root.val+right);</span><br><span class="line">        <span class="keyword">int</span> maxVal=Math.max(returnVal,root.val+left+right);</span><br><span class="line"></span><br><span class="line">        max=Math.max(maxVal,max);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-anagrams/">49. 字母异位词分组</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.取出String中的每个string</span></span><br><span class="line"><span class="comment">        2.将String变成charArray</span></span><br><span class="line"><span class="comment">        3.排序。</span></span><br><span class="line"><span class="comment">        4.用map放下key和value</span></span><br><span class="line"><span class="comment">        5.将map同一个key下面的value返回</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        HashMap&lt;String,List&lt;String&gt;&gt; map=<span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span>(String str:strs)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] charArray=str.toCharArray();</span><br><span class="line">            Arrays.sort(charArray);</span><br><span class="line">            <span class="comment">//String str1=charArray.toString(); 这个写法不对诶，hashMap里面的String相等是要自己定义吗</span></span><br><span class="line">            String str1=<span class="keyword">new</span> String(charArray);</span><br><span class="line">            List&lt;String&gt; list=map.getOrDefault(str1,<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(str1,list);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; val:map.values())&#123;</span><br><span class="line">            res.add(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h4><p>对于一开始没有思路的题目，要学会使用暴力解法解题，然后分析暴力解法的问题，然后进行优化。</p>
<p>如果不考虑时间复杂度，我会怎么想这道题呢？</p>
<p>我会从A数组的第一个字母开始，遍历A数组字母，然后与B数组字母比较，最后获得最长的数组的长度并记录下来，伪代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于A数组的元素：</span><br><span class="line">    对于B数组的元素：</span><br><span class="line">    	如果相等 计数器++</span><br><span class="line">    		A数组的指针和B数组的指针加加</span><br><span class="line">    	如果不等 计数器清零 然后A数组又从头开始</span><br></pre></td></tr></table></figure>



<p>这个时候考虑移动A的位置，让A可以错位和B比较：</p>
<p>​    1.若A的长度为i，B的长度为m。</p>
<p>​    2.则A可以以B起点0的位置到B起点m的位置比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sameLength</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span> []nums2,<span class="keyword">int</span> addA,<span class="keyword">int</span> addB,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;<span class="comment">//对于数组问题，一定要考虑到的是可以访问的边界</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums[addA+i]==nums[addB+i])&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        ret=Math.max(ret,count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>外层的函数为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)</span><br><span class="line"></span><br><span class="line">由于需要记录滑动窗口的最大值，考虑维护一个优先队列，队列维护值和索引两个量。按照值的大小进行排序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">开始将前K个数放入队列中，然后扩展窗口。扩展的过程中，添加新的数到队列中，然后获取队列的头部到答案中，但是要注意，对于索引已经不在窗内的值直接丢弃，直到数被包含在窗口内。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">所以：</span><br><span class="line"></span><br><span class="line">​	<span class="number">1.</span>建立优先队列。</span><br><span class="line"></span><br><span class="line">​	<span class="number">2.</span>将K个数放入优先队列。</span><br><span class="line"></span><br><span class="line">​	<span class="number">3.</span>对优先队列的每个数，如果队首的数在范围内，添加队首的数到答案；如果不在范围，一直出队，直到队首的数在窗内。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; priorityQueue=<span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;((pair1,pair2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> pair1[<span class="number">0</span>]==pair2[<span class="number">0</span>]?pair2[<span class="number">1</span>]-pair2[<span class="number">1</span>]:pair2[<span class="number">0</span>]-pair1[<span class="number">0</span>]; </span><br><span class="line">        &#125;);<span class="comment">//记忆这里的lambda表达式，这里lambda实现了匿名类的方法之后直接就替代了匿名类</span></span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            priorityQueue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i],i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ans=<span class="keyword">new</span> <span class="keyword">int</span>[len-k+<span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>]=priorityQueue.peek()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;len;i++)&#123;</span><br><span class="line">            priorityQueue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i],i&#125;);</span><br><span class="line">            <span class="keyword">while</span>(priorityQueue.peek()[<span class="number">1</span>]&lt;i-k+<span class="number">1</span>)&#123;</span><br><span class="line">                priorityQueue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i-k+<span class="number">1</span>]=priorityQueue.peek()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] need=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span>[] windows=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.t为被覆盖的。</span></span><br><span class="line"><span class="comment">            2.维护一个need数组，记录t中每个字符的个数</span></span><br><span class="line"><span class="comment">            3.从left=0，right=0开始开始遍历s，对于扩大窗口的时候，判断进入窗口的字符：</span></span><br><span class="line"><span class="comment">                1.如果是need中的元素，那么windows对应++，并且检验一下是否符合条件了</span></span><br><span class="line"><span class="comment">                2.如果不是need中的元素，那么直接移动</span></span><br><span class="line"><span class="comment">            4.当判断已经符合条件的时候，此时缩小窗口，left++，对于移出窗口的元素，如果不是need中的元素，可以继续；如果是，那么就要处理windows并处理符合的状态</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] tArray=t.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:tArray)&#123;</span><br><span class="line">            need[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] sArray=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxL=s.length()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(need[sArray[right]]&gt;windows[sArray[right]])&#123;</span><br><span class="line">                count++;<span class="comment">//如果此时windows还没有对应填满，此时会增加一个计数</span></span><br><span class="line">            &#125;</span><br><span class="line">            windows[sArray[right]]++;</span><br><span class="line">            right++; </span><br><span class="line">            <span class="keyword">while</span>(count==t.length())&#123;<span class="comment">//当窗口符合条件</span></span><br><span class="line">                <span class="keyword">if</span>(right-left&lt;maxL)&#123;</span><br><span class="line">                    maxL=right-left;</span><br><span class="line">                    start=left;</span><br><span class="line">                    end=right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(need[sArray[left]]==windows[sArray[left]])count--;<span class="comment">//注意这里，只有当如果将left移出去就会使得不符合条件的时候，才需要跳出循环</span></span><br><span class="line">                windows[sArray[left]]--;</span><br><span class="line">                left=left+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxL==s.length()+<span class="number">1</span>)<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><h4 id="478-在圆内随机生成点"><a href="#478-在圆内随机生成点" class="headerlink" title="478. 在圆内随机生成点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-random-point-in-a-circle/">478. 在圆内随机生成点</a></h4><p><strong>代码出现错误的点：变量名写着写着就忘记了~依靠自动补全补错变量名，记住random的api</strong></p>
<p>首先是要记住一些api，比如Math.pow(num,2);再比如Math.random()</p>
<p>Math.random()生成[0,1）的double类型数据。</p>
<p>由于生成的范围都是正方形，所以对于正方形外面的要丢弃。</p>
<p>当然，也可以考虑用极坐标来解决问题。但是要注意极坐标在选取半径的长度的时候，半径的长度也应该符合概率分布。由于圆的面积是r^2，因此半径的概率分布应该是double d = rad * Math.sqrt(Math.random());</p>
<p>用第一种方法就够了吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x_center;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y_center;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius=radius;</span><br><span class="line">        <span class="keyword">this</span>.y_center=y_center;</span><br><span class="line">        <span class="keyword">this</span>.x_center=x_center;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] randPoint() &#123;</span><br><span class="line">        <span class="keyword">double</span> x_ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> y_ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> x_start=x_center-radius;</span><br><span class="line">        <span class="keyword">double</span> y_start=y_center-radius;</span><br><span class="line">        <span class="keyword">double</span> distance=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            x_ans=x_start+radius*<span class="number">2</span>*Math.random();</span><br><span class="line">            y_ans=y_start+radius*<span class="number">2</span>*Math.random();</span><br><span class="line">            <span class="keyword">double</span> x_distance=Math.pow((x_ans-x_center),<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">double</span> y_distance=Math.pow((y_ans-y_center),<span class="number">2</span>);</span><br><span class="line">            distance=Math.sqrt(x_distance+y_distance);</span><br><span class="line">        &#125;<span class="keyword">while</span>(distance&gt;radius);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;x_ans,y_ans&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(radius, x_center, y_center);</span></span><br><span class="line"><span class="comment"> * double[] param_1 = obj.randPoint();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h4><p>java中的异或: ^    </p>
<h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.单调栈的思路。</span></span><br><span class="line"><span class="comment">        2.对于还没有找到更高温度的，想要将该值存储起来。因此考虑用栈。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        1.维护一个栈，对于一个元素，先入栈，然后比较后一个元素和该元素索引对应值。如果新元素较大，那么就将旧元素出栈，然后返回结果。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Deque&lt;Integer&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len=temperatures.length;</span><br><span class="line">        <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;temperatures[i]&gt;temperatures[stack.peek()])&#123;<span class="comment">//是peek不是peak</span></span><br><span class="line">                <span class="keyword">int</span> index=stack.pop();<span class="comment">//注意语法</span></span><br><span class="line">                result[index]=i-index;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);<span class="comment">//注意语法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=returnLeft(nums,target);</span><br><span class="line">        <span class="keyword">int</span> right=returnRight(nums,target);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right-left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">returnLeft</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=nums.length||nums[left]!=target)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">returnRight</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;<span class="number">0</span>||nums[right]!=target)<span class="keyword">return</span> -<span class="number">2</span>;<span class="comment">//注意对范围的判断</span></span><br><span class="line">        <span class="keyword">return</span> right;<span class="comment">//这道题出现的一个错误是括号的位置放置错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a></h4><p>发现有些题解是讲得真清楚。<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1rb411T7dR?from=search&amp;seid=5879260362287173147">https://www.bilibili.com/video/BV1rb411T7dR?from=search&amp;seid=5879260362287173147</a></p>
<p>没有状态的时候就看看视频呗。思路很巧妙，记忆题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            max=Math.max(max,num);</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low=max;<span class="comment">//集合的值最小是max</span></span><br><span class="line">        <span class="keyword">int</span> high=sum;<span class="comment">//这里主要要记住的就是low和high的赋值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123; <span class="comment">//这个二分搜索的边界是怎么写的值得注意，自己没有写对</span></span><br><span class="line">            <span class="keyword">int</span> mid=low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> piecies=split(nums,mid);</span><br><span class="line">            <span class="keyword">if</span>(piecies&gt;m)&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span>[]nums,<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> piecies=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum+num&gt;count)&#123;</span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">                piecies++;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> piecies;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上述解法比较固定，只能针对这道题。其实就是有一个可能的返回范围，然后进行猜数，这种返回一定范围内答案的题目可以考虑使用二分搜索，然后再计算块数的时候自己还是犯了错误，还是要小心</span></span><br></pre></td></tr></table></figure>



<h4 id="528-按权重随机选择"><a href="#528-按权重随机选择" class="headerlink" title="528. 按权重随机选择"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/random-pick-with-weight/">528. 按权重随机选择</a></h4><p>此题实际上也是一道记忆体，因为要理解题目的意思。这里将题目的意思翻译一下：</p>
<p>比如说给一个数组：[1,2,7,2]</p>
<p>这里的意思是选择下标为1的概率是1/(1+2+7+2)。</p>
<p>这里我们考虑在0-sum-1的范围内随机生成一个数，其实就是实现了这里的1/sum。</p>
<p>由于每个数都有不同的权重，因此，我们希望，如果随机生成的randomInt在不同的范围内，对应不同的下标。以上面的数组为例：</p>
<p>1对应的应该是0这个数。</p>
<p>而2对应的是1,2这两个数。</p>
<p>7对应的是3,4,5,6,7,8,9这7个数。</p>
<p>因此，当在一定范围内产生数据之后，后面其实就是判断范围的事情了。</p>
<p>同时，我们观察到，判断范围的是累加和数组，比如上面。</p>
<p>[0,1,3,10,12]</p>
<p>如果是0,1,3,10取==号时是0,1,2,3这三个下标，</p>
<p>同时往下取。即找右边界。</p>
<h4 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29. 两数相除"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/divide-two-integers/">29. 两数相除</a></h4><p>这道题也主要是记忆这个方法。就是可以将数写成div*2的次幂组合的形式。</p>
<p>然后通过逐次减去对应的指数即</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(a&gt;=b)&#123;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;b&lt;&lt;shift)&#123;<span class="comment">//用上面的例子相当于是先减去4*2^2，然后减去4*2^1.类推</span></span><br><span class="line">        shift--;</span><br><span class="line">    &#125;</span><br><span class="line">    a=a-b&lt;&lt;shift;</span><br><span class="line">    res+=<span class="number">1</span>&lt;&lt;shift;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h4><p>思路其实还比较简单，见注释，不过有很多可能错误的细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.用递归的思路解决这个问题。</span></span><br><span class="line"><span class="comment">        2.首先分段，找到k个节点。</span></span><br><span class="line"><span class="comment">        3.对于k个节点做反转，传入k个节点的首节点以及后面的尾节点，返回头节点。</span></span><br><span class="line"><span class="comment">        4.对后面递归做这个动作，需要保证前面一段的尾部连接到后面的递归返回的头节点中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        ListNode  tail=cur;</span><br><span class="line">        ListNode returnHead=reverse(head,tail);</span><br><span class="line">        head.next=reverseKGroup(tail,k);</span><br><span class="line">        <span class="keyword">return</span> returnHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head,ListNode tail)</span></span>&#123;</span><br><span class="line">        ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">        ListNode next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=tail)&#123;</span><br><span class="line">            next=head.next;</span><br><span class="line">            head.next=pre;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4><h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.预留下pre节点，可以申请一个dummyHead</span></span><br><span class="line"><span class="comment">        2.返回一个头结点，可以被预留的节点返回</span></span><br><span class="line"><span class="comment">        3.预留下尾部节点最后反转的时候最后指向尾部节点</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(right==left)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummyHead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next=head;</span><br><span class="line">        ListNode pre=dummyHead;</span><br><span class="line">        ListNode leftNode=dummyHead.next;</span><br><span class="line">        ListNode rightNode=dummyHead.next;</span><br><span class="line">        <span class="keyword">while</span>(left-<span class="number">1</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            leftNode=leftNode.next;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right-<span class="number">1</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            rightNode=rightNode.next;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tail=rightNode.next;</span><br><span class="line">        reverse(leftNode,tail);</span><br><span class="line">        pre.next=rightNode;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ListNode LeftNode,ListNode tail)</span></span>&#123;</span><br><span class="line">        ListNode pre=tail;</span><br><span class="line">        ListNode cur=LeftNode;</span><br><span class="line">        ListNode next=LeftNode.next;</span><br><span class="line">        <span class="keyword">while</span>(cur!=tail)&#123;</span><br><span class="line">            cur.next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">            next=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h4><h4 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.找到中点。</span></span><br><span class="line"><span class="comment">        2.反转链表</span></span><br><span class="line"><span class="comment">        3.连接链表</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        ListNode mid=findMid(head);</span><br><span class="line">        ListNode secondHead=mid.next;</span><br><span class="line">        mid.next=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        secondHead=reverse(secondHead);</span><br><span class="line">        ListNode cur1=head;</span><br><span class="line">        ListNode cur2=secondHead;</span><br><span class="line">        <span class="keyword">while</span>(cur1!=<span class="keyword">null</span>&amp;&amp;cur2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next1=cur1.next;</span><br><span class="line">            ListNode next2=cur2.next;</span><br><span class="line">            cur1.next=cur2;</span><br><span class="line">            cur2.next=next1;</span><br><span class="line">            cur1=next1;</span><br><span class="line">            cur2=next2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findMid</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next=cur.next;</span><br><span class="line">            cur.next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分而治之解决问题。</p>
<h4 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.使用两个栈，一个对数据进行监控，一个对当前最小值进行监控。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; minStack;</span><br><span class="line">    Deque&lt;Integer&gt; stack;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minStack=<span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">        stack=<span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        stack.push(val);</span><br><span class="line">        <span class="keyword">if</span>(minStack.isEmpty()||val&lt;=minStack.peek())&#123;</span><br><span class="line">            minStack.push(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(num==minStack.peek())&#123;</span><br><span class="line">            minStack.pop();<span class="comment">//代码尽量写规范，自己这里写得不规范然后就报错了</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	之前的写法：</span></span><br><span class="line"><span class="comment">            	if(minStack.peek()==stack.pop())&#123;</span></span><br><span class="line"><span class="comment">            		minStack.pop();出现了错误，是什么原因</span></span><br><span class="line"><span class="comment">            	&#125;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





<h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h4><p>很简单的题目，但是没有注意细节，没有想清楚就可能卡住半天。</p>
<p>下面是错误解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode mid=findMid(head);</span><br><span class="line">        mid=reverse(mid.next);</span><br><span class="line">        ListNode cur1=head;</span><br><span class="line">        ListNode cur2=mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur1!=<span class="keyword">null</span>&amp;&amp;cur2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1.val!=cur2.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            cur1=cur1.next;</span><br><span class="line">            cur2=cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur1!=<span class="keyword">null</span>||cur2!=<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//千万要注意，这个时候链表又没有断开，不能用这种方法判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findMid</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>&amp;&amp;fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow;<span class="comment">//这里返回的是什么用例子想一下</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next=cur.next;</span><br><span class="line">            cur.next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/compare-version-numbers/">165. 比较版本号</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">    String[] nums1 = version1.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">    String[] nums2 = version2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> n1 = nums1.length, n2 = nums2.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compare versions</span></span><br><span class="line">    <span class="keyword">int</span> i1, i2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.max(n1, n2); ++i) &#123;</span><br><span class="line">      i1 = i &lt; n1 ? Integer.parseInt(nums1[i]) : <span class="number">0</span>;</span><br><span class="line">      i2 = i &lt; n2 ? Integer.parseInt(nums2[i]) : <span class="number">0</span>;<span class="comment">//记住API，前导0直接忽略</span></span><br><span class="line">      <span class="keyword">if</span> (i1 != i2) &#123;</span><br><span class="line">        <span class="keyword">return</span> i1 &gt; i2 ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the versions are equal</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxlength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, <span class="number">2</span> * right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = right = <span class="number">0</span>;<span class="comment">//注意两个过程切换的时候需要做的一个初始化过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, <span class="number">2</span> * left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h4 id="468-验证IP地址"><a href="#468-验证IP地址" class="headerlink" title="468. 验证IP地址"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-ip-address/">468. 验证IP地址</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">validIPAddress</span><span class="params">(String IP)</span> </span>&#123;</span><br><span class="line">        IP=IP.toLowerCase();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.判断ipv4和ipv6.</span></span><br><span class="line"><span class="comment">        2.ipv4</span></span><br><span class="line"><span class="comment">            4组</span></span><br><span class="line"><span class="comment">            0-255 但是注意不会用0开头</span></span><br><span class="line"><span class="comment">            用.分隔</span></span><br><span class="line"><span class="comment">        3.ipv6</span></span><br><span class="line"><span class="comment">            8组</span></span><br><span class="line"><span class="comment">            16进制</span></span><br><span class="line"><span class="comment">            最多4个字母</span></span><br><span class="line"><span class="comment">            ：分割</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(IP.contains(<span class="string">&quot;.&quot;</span>))&#123;</span><br><span class="line">            String[] str=IP.split(<span class="string">&quot;\\.&quot;</span>,-<span class="number">1</span>);<span class="comment">//这里注意，limit=-1的情况下，这里会尽可能分割，包括分割长度为0的情况</span></span><br><span class="line">            <span class="keyword">if</span>(str.length!=<span class="number">4</span>)<span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;<span class="comment">//不允许0开头，不超过255</span></span><br><span class="line">                String s=str[i];</span><br><span class="line">                <span class="keyword">if</span>(s.length()==<span class="number">0</span>||s.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>&amp;&amp;s.length()&gt;<span class="number">1</span>||s.length()&gt;<span class="number">3</span>)<span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">                    <span class="keyword">char</span> ch=s.charAt(j);</span><br><span class="line">                    <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> num=Integer.parseInt(s);</span><br><span class="line">                <span class="keyword">if</span>(num&lt;<span class="number">0</span>||num&gt;<span class="number">255</span>)<span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IPv4&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(IP.contains(<span class="string">&quot;:&quot;</span>))&#123;</span><br><span class="line">            String[] str=IP.split(<span class="string">&quot;:&quot;</span>,-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(str.length!=<span class="number">8</span>)<span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isDigit(str[i]))<span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">                <span class="keyword">int</span> len=str[i].length();</span><br><span class="line">                <span class="keyword">if</span>(len==<span class="number">0</span>||len&gt;<span class="number">4</span>)<span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IPv6&quot;</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] charArray=str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:charArray)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;<span class="string">&#x27;0&#x27;</span>&lt;=ch||ch&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;f&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[row+<span class="number">1</span>][col+<span class="number">1</span>]; <span class="comment">//注意这里dp预留一个1的写法，根据dp的转移式子列写dp方程</span></span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                max=Math.max(max,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max*max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以练习一下<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/">1277. 统计全为 1 的正方形子矩阵</a>，其实是一样的解法。</p>
<h4 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h4><p>本质是利用了set这个数据结构的查找优势来简化了步骤。</p>
<p>但是要注意一个trick：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashSet&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(set.contains(num-<span class="number">1</span>))<span class="keyword">continue</span>;<span class="comment">//对于之前遍历过的，要记得省略</span></span><br><span class="line">            <span class="keyword">int</span> currentNum=num;</span><br><span class="line">            <span class="keyword">int</span> currentLength=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(set.contains(currentNum+<span class="number">1</span>))&#123;</span><br><span class="line">                currentLength++;</span><br><span class="line">                currentNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            max=Math.max(max,currentLength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator-ii/">227. 基本计算器 II</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 map 维护一个运算符优先级</span></span><br><span class="line">    <span class="comment">// 这里的优先级划分按照「数学」进行划分即可</span></span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;()&#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;%&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;^&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将所有的空格去掉</span></span><br><span class="line">        s = s.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);<span class="comment">//ATTENTION</span></span><br><span class="line">        <span class="keyword">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// 存放所有的数字</span></span><br><span class="line">        Deque&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">// 为了防止第一个数为负数，先往 nums 加个 0</span></span><br><span class="line">        nums.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 存放所有「非数字以外」的操作</span></span><br><span class="line">        Deque&lt;Character&gt; ops = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = cs[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ops.addLast(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 计算到最近一个左括号为止</span></span><br><span class="line">                <span class="keyword">while</span> (!ops.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ops.peekLast() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        calc(nums, ops);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ops.pollLast();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNumber(c)) &#123;</span><br><span class="line">                    <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> j = i;</span><br><span class="line">                    <span class="comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; n &amp;&amp; isNumber(cs[j])) u = u * <span class="number">10</span> + (cs[j++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    nums.addLast(u);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 有一个新操作要入栈时，先把栈内可以算的都算了 </span></span><br><span class="line">                    <span class="comment">// 只有满足「栈内运算符」比「当前运算符」优先级高/同等，才进行运算</span></span><br><span class="line">                    <span class="keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">char</span> prev = ops.peekLast();</span><br><span class="line">                        <span class="keyword">if</span> (map.get(prev) &gt;= map.get(c)) &#123;</span><br><span class="line">                            calc(nums, ops);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ops.addLast(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将剩余的计算完</span></span><br><span class="line">        <span class="keyword">while</span> (!ops.isEmpty()) calc(nums, ops);</span><br><span class="line">        <span class="keyword">return</span> nums.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ops.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> b = nums.pollLast(), a = nums.pollLast();</span><br><span class="line">        <span class="keyword">char</span> op = ops.pollLast();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) ans = a + b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>) ans = a - b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span>) ans = a * b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;/&#x27;</span>)  ans = a / b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;^&#x27;</span>) ans = (<span class="keyword">int</span>)Math.pow(a, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;%&#x27;</span>) ans = a % b;</span><br><span class="line">        nums.addLast(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Character.isDigit(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须反复练习，孰能生巧。</p>
<p>下面是switch语句的语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(grade)<span class="comment">//直接加大括号，不加引号</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> :</span><br><span class="line">      System.out.println(<span class="string">&quot;优秀&quot;</span>); </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span> :</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span> :</span><br><span class="line">      System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> :</span><br><span class="line">      System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span> :</span><br><span class="line">      System.out.println(<span class="string">&quot;你需要再努力努力&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span> :</span><br><span class="line">      System.out.println(<span class="string">&quot;未知等级&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>出现的错误：</p>
<p>1.hashmap的初始化语句出错。注意如何初始化。</p>
<p>2.swtich拼写错误，语法不熟悉。</p>
<p>3.有一个函数忘记实现了。</p>
<p>不熟练的点：<strong>对连续数的处理。以及对符号进栈时候的处理。要加强练习。</strong></p>
<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length-<span class="number">2</span>;i++)&#123;  <span class="comment">//注意是length-2</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">int</span> left=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right=length-<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]==<span class="number">0</span>)&#123;</span><br><span class="line">                    ans.add(List.of(nums[i],nums[left],nums[right]));<span class="comment">//注意该语法</span></span><br><span class="line">                   </span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])left++;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right-<span class="number">1</span>])right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;<span class="comment">//这里忘记了移动指针，要分清楚每一步做了什么事情</span></span><br><span class="line">                    </span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记忆点：</p>
<p>​    三数之和的难点在于去重复的设计。这里的策略是：</p>
<p>​    对于基准的外层的第一个数字i，是采用先去重，再使用的策略，就是说使用第一个有效的数字。</p>
<p>​    对于外层的left和right，则首先将符合条件的加入，然后一直往后推进直到不重复。这里可能难想一点。</p>
<p>然后是一个kpi。 res.add(List.of(nums[i],left,right));</p>
<p>然后是指针移动题目，要分清楚每个if else 做的事情，不要忘记移动指针。</p>
<h3 id="460-LFU-缓存"><a href="#460-LFU-缓存" class="headerlink" title="460. LFU 缓存"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a></h3><p>题意描述：</p>
<p>1.常数时间查找到节点： map存储节点。</p>
<p>2.常数时间更改节点。</p>
<p>3.插入节点时候做判断：</p>
<p>​    1.排除最不常使用项目。[建立频率和双向链表映射]</p>
<p>​    2.使用最不常使用中的最久不使用项目。[插入双向链表]</p>
<p>实现两个函数：</p>
<p>​    get:</p>
<p>​        1.如果map有，</p>
<p>​                将节点的cnt++；</p>
<p>​                在原来的链表删除；  1链表删除。2.map删除。</p>
<p>​                添加新的链表                1.添加链表。2.添加map。</p>
<p>​        2.否则返回-1；</p>
<p>​    put:</p>
<p>​        1.如果map有：</p>
<p>​                        1.获取节点。</p>
<p>​                        </p>
<p>​                         3.删除原来的节点，记录使用的频率。</p>
<p>​                         4.原来的频率加1，更新值，形成新的节点。</p>
<p>​                          5.新的节点插入新的频率链表。</p>
<p>​          2.如果map没有：</p>
<p>​                        1.创建新节点，频率为1.</p>
<p>​                         2.插入频率为1的节点。</p>
<p>​                        3.判断容量是否超标。</p>
<p>​                        4.如果超出容量，则依据使用频率遍历列表，取出列表中的尾部节点。注意取出之后跳出。</p>
<p>LFU 的数据结构：</p>
<p>1.两个map。分别是key—node和key-list。</p>
<p>2.list是双向链表。</p>
<p>3.get操作：</p>
<p>​    1.如果没有，返回-1；</p>
<p>​    2.如果有，首先返回值，然后做更新操作。</p>
<p>​            3.node的频率加1.</p>
<p>​            4.将node从原来的list中移除。</p>
<p>​            5.将node添加到现在对应的频率Dlist中。</p>
<p>4.put操作：</p>
<p>​    1.如果已经有了，做更新操作。同时执行get即可。</p>
<p>​    2.如果没有</p>
<p>​            1.生成node，将node添加到频率为1的队列中。（头插入</p>
<p>​            2.如果出现了capacity溢出的情况，</p>
<p>​                    3.如果队列为1的队列长度》1,删除队列为1 的节点，删除尾部</p>
<p>​                            4.如果队列为1 的队列长度为1，那么就往高频率的队列往上查找。</p>
<p>​                                    5.特殊情况：如果capacity==0，那么就不管如何直接返回。</p>
<p>这里需要分析一下错误原因，之前错误的有两点：</p>
<p>1.一点是在remove里面管辖了map的操作，导致逻辑错误。</p>
<p>2另外一点是在get里面操作了节点的cnt。</p>
<p>因此，规定可以操作的范围是必要的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcodeTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leetcodeLFU</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> val;</span><br><span class="line">            <span class="keyword">int</span> key;</span><br><span class="line">            <span class="keyword">int</span> cnt;</span><br><span class="line">            Node pre;</span><br><span class="line">            Node next;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.val=val;</span><br><span class="line">                <span class="keyword">this</span>.cnt=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>.key=key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Dlist</span></span>&#123;</span><br><span class="line">            Node head;</span><br><span class="line">            Node tail;</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Dlist</span><span class="params">()</span></span>&#123;</span><br><span class="line">                head=<span class="keyword">new</span> Node(-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                tail=<span class="keyword">new</span> Node(-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                head.next=tail;</span><br><span class="line">                tail.pre=head;</span><br><span class="line">                len=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">                len=len-<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//nMap.remove(node.key);</span></span><br><span class="line">                Node pre=node.pre;</span><br><span class="line">                Node next=node.next;</span><br><span class="line">                pre.next=next;</span><br><span class="line">                next.pre=pre;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">                node.next=head.next;</span><br><span class="line">                head.next.pre=node;</span><br><span class="line">                node.pre=head;</span><br><span class="line">                head.next=node;</span><br><span class="line">                len=len+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> capacity;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer,Node&gt; nMap;</span><br><span class="line">        Map&lt;Integer,Dlist&gt; fMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.capacity=capacity;</span><br><span class="line">            size=<span class="number">0</span>;</span><br><span class="line">            nMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            fMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            fMap.put(<span class="number">1</span>,<span class="keyword">new</span> Dlist());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!nMap.containsKey(key))<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                Node node=nMap.get(key);</span><br><span class="line">                <span class="keyword">int</span> preF=node.cnt;</span><br><span class="line">                node.cnt++;<span class="comment">//2</span></span><br><span class="line">                Dlist preList=fMap.get(preF);</span><br><span class="line">               <span class="comment">// preList.remove(node);//注意长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                Dlist curList=fMap.getOrDefault(node.cnt,<span class="keyword">new</span> Dlist());</span><br><span class="line">                curList.add(node);<span class="comment">//注意长度</span></span><br><span class="line"></span><br><span class="line">                fMap.put(node.cnt,curList);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> node.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nMap.containsKey(key))&#123;</span><br><span class="line">                Node node=nMap.get(key);</span><br><span class="line">                node.val=value;</span><br><span class="line">                <span class="comment">//node.cnt++;</span></span><br><span class="line">                get(node.key);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                size++;</span><br><span class="line">                Dlist list1=fMap.get(<span class="number">1</span>);</span><br><span class="line">                Node node=<span class="keyword">new</span> Node(key,value);</span><br><span class="line">                list1.add(node);</span><br><span class="line">                nMap.put(key,node);</span><br><span class="line">                <span class="keyword">if</span>(size&gt;capacity)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(list1.len&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                        list1.remove(list1.tail.pre);<span class="comment">//注意也要从nMap中删除，长度要记得变化</span></span><br><span class="line">                        nMap.remove(node.key);</span><br><span class="line">                        size--;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=fMap.size();i++)&#123;</span><br><span class="line">                        Dlist list=fMap.get(i);</span><br><span class="line">                        <span class="keyword">if</span>(list.len&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                            list.remove(list.tail.pre);</span><br><span class="line">                            nMap.remove(node.key);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">     * LFUCache obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment">     * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment">     * obj.put(key,value);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LFUCache testCache = <span class="keyword">new</span> LFUCache(<span class="number">2</span>);</span><br><span class="line">        testCache.put(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        testCache.put(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">       <span class="comment">// testCache.get(1);</span></span><br><span class="line">        <span class="comment">// get1=testCache.get(1);</span></span><br><span class="line">       testCache.put(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">       testCache.put(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">       <span class="comment">//testCache.get(2);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></h4><p>要记忆一下相乘的策略。</p>
<p>这里输入是n,m位的数组，两个数组相乘的结果最多是m+n位：</p>
<p>​    对于每一位，乘积的结果可能为2位数。2位数的个位放置在i+j+1的位置，十位放置在i+j的位置。</p>
<p>然后遵守答案，应该从前往后遍历，去掉可能存在的前导0。</p>
<p>不知道哪里错了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1=num1.length();</span><br><span class="line">        <span class="keyword">int</span> len2=num2.length();</span><br><span class="line">        <span class="keyword">if</span>(len1==<span class="number">0</span>||len2==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">char</span>[] num1Array=num1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] num2Array=num2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] res=<span class="keyword">new</span> <span class="keyword">char</span>[len1+len2];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(res,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len1-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;<span class="comment">//这里要取到0，弄错了，没有加等号</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=len2-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> multiAns=(num1Array[i]-<span class="string">&#x27;0&#x27;</span>)*(num2Array[j]-<span class="string">&#x27;0&#x27;</span>)+(res[i+j+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                res[i+j+<span class="number">1</span>]=(<span class="keyword">char</span>)(multiAns%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                res[i+j]=(<span class="keyword">char</span>)(multiAns/<span class="number">10</span>+res[i+j]);<span class="comment">//注意想清楚乘法，多位相乘到底是什么情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> seen=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1+len2;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;!seen)<span class="keyword">continue</span>;</span><br><span class="line">            sb.append(res[i]);</span><br><span class="line">            seen=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.length()==<span class="number">0</span>?<span class="string">&quot;0&quot;</span>:sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1=num1.length();</span><br><span class="line">        <span class="keyword">int</span> len2=num2.length();</span><br><span class="line">        <span class="keyword">if</span>(len1==<span class="number">0</span>||len2==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">char</span>[] num1Array=num1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] num2Array=num2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] res=<span class="keyword">new</span> <span class="keyword">char</span>[len1+len2];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(res,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len1-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=len2-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> num1Temp=(<span class="keyword">int</span>)(num1Array[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">int</span> num2Temp=(<span class="keyword">int</span>)(num2Array[j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">int</span> temp=num1Temp*num2Temp+(<span class="keyword">int</span>)(res[i+j+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">int</span> tempFirst=temp%<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">int</span> tempSecond=temp/<span class="number">10</span>;</span><br><span class="line">                res[i+j+<span class="number">1</span>]=(<span class="keyword">char</span>)(tempFirst+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                res[i+j]=(<span class="keyword">char</span>)(tempSecond+<span class="string">&#x27;0&#x27;</span>+res[i+j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> seen=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1+len2;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;!seen)<span class="keyword">continue</span>;</span><br><span class="line">            sb.append(res[i]);</span><br><span class="line">            seen=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.length()==<span class="number">0</span>?<span class="string">&quot;0&quot;</span>:sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误原因：</p>
<p>​    1.for循环的终止条件写错。查了很久还是没查出来。</p>
<p>​    2.乘法少想了一位。</p>
<h4 id="498-对角线遍历"><a href="#498-对角线遍历" class="headerlink" title="498. 对角线遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diagonal-traverse/">498. 对角线遍历</a></h4><p>方向遍历题目。主要是考察细节和细心。不要怕麻烦，将矩阵的搜索移动用几个固定的算法给描述出来。</p>
<p>类比的想法是第54题，可以一起看看。</p>
<p>这里相当于试探查找。首先找到1，这个时候方向是斜向上的。然后到边界之后，开始尝试向右，向右如果在边界中，那么方向换向。然后再找。</p>
<p>简单描述如下：</p>
<p>​    方向1查找</p>
<p>​            找到边界</p>
<p>​                    如果可以右边走</p>
<p>​                            右边走</p>
<p>​                            换方向直到边界</p>
<p>​                    如果可以往下边走</p>
<p>​                            下边走</p>
<p>​                            换方向到边界</p>
<p>错误描述：</p>
<p>1.注意 1不是boolean值，要用true。</p>
<p>2.方向弄错，上下左右的方向弄错了。和i和j的关系弄错了。i+1是向下。然后是符号位的变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findDiagonalOrder(<span class="keyword">int</span>[][] mat) &#123;</span><br><span class="line">        <span class="keyword">int</span> col=mat.length;</span><br><span class="line">        <span class="keyword">int</span> row=mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(col==<span class="number">0</span>||row==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span>[]res=<span class="keyword">new</span> <span class="keyword">int</span>[col*row];</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> rightUp=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            res[count]=mat[i][j];</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count==row*col)<span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">if</span>(rightUp)&#123;     </span><br><span class="line">                <span class="keyword">if</span>((i-<span class="number">1</span>)&gt;=<span class="number">0</span>&amp;&amp;(j+<span class="number">1</span>)&lt;row)&#123;<span class="comment">// (i+1)&lt;col&amp;&amp;(j+1)&lt;row</span></span><br><span class="line">                    i=i-<span class="number">1</span>; <span class="comment">//上</span></span><br><span class="line">                    j=j+<span class="number">1</span>; <span class="comment">//右</span></span><br><span class="line">                   </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;row)&#123;</span><br><span class="line">                        j=j+<span class="number">1</span>;<span class="comment">//右</span></span><br><span class="line">                       </span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        i=i+<span class="number">1</span>;<span class="comment">//下</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    rightUp=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>((i+<span class="number">1</span>)&lt;col&amp;&amp;(j-<span class="number">1</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    i=i+<span class="number">1</span>;<span class="comment">//下</span></span><br><span class="line">                    j=j-<span class="number">1</span>;<span class="comment">//左</span></span><br><span class="line">                   </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;col)&#123;</span><br><span class="line">                        i=i+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        j=j+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    rightUp=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        Arrays.fill(dp,amount+<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=amount;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> coin:coins)&#123;</span><br><span class="line">                <span class="keyword">if</span>(coin&gt;i)<span class="keyword">continue</span>;</span><br><span class="line">                dp[i]=Math.min(dp[i],dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]==amount+<span class="number">1</span>?-<span class="number">1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-string/">394. 字符串解码</a></h4><p>用一个例子来进行分析：</p>
<p>​    3[a2[c]]</p>
<p>​    2[abc]3[cd]ef</p>
<p>考虑建立 数字栈和字符串栈（栈建立的意义是先存储再使用，数字是需要一会儿使用的，然后字符串也可能会一会儿使用，然后就考虑遇到不同的东西的时候的行为）</p>
<p>遇到数字：</p>
<p>​    数字入栈</p>
<p>遇到[：</p>
<p>​    tail入栈</p>
<p>遇到字母：</p>
<p>​    tail.append</p>
<p>遇到]:</p>
<p>​    1.这个时候tail应该有一串内容了。</p>
<p>​    2.出栈数字，然后重复添加tail的内容。</p>
<p>​    3.放入栈中。</p>
<h4 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h4><p>这道题一开始想到了动态规划。但是自己否决了。因为动态规划的时候，觉得有个负数，无法判断。但是其实如果是负数的话，其实就是多维持一个最小值。自己还是应该多想一步。</p>
<p>维持上一个步骤的最小值和最大值，下一步再在上一步的基础上计算即可得到结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] minDp=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] maxDp=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        minDp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        maxDp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            minDp[i]=Math.min(minDp[i-<span class="number">1</span>]*nums[i],Math.min(nums[i],maxDp[i-<span class="number">1</span>]*nums[i]));<span class="comment">//要比较三个数</span></span><br><span class="line">            maxDp[i]=Math.max((minDp[i-<span class="number">1</span>]*nums[i],Math.max(nums[i],maxDp[i-<span class="number">1</span>]*nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:maxDp)&#123;</span><br><span class="line">            max=Math.max(max,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h4><p>类似于斐波那契数列。这里难点还是dp的确立。</p>
<p>dp[n]=dp[n-1]+dp[n-2]。这里理解一点，之所以这里dp[n-1]和dp[n-2]是不同的两个方法，在于其最后一步一定是不一样的。比如dp[n-1]最后一步是1，而dp[n-2]最后一步是2。</p>
<p>另外，题目要求最后的结果要对1000000007取余。这里记住，在计算过程中取余是等价的。</p>
<h4 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数</a></h4><p>这是一道记忆题。关键是要记住这种位与然后消去1的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            n=n&amp;(n-<span class="number">1</span>);</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome/">125. 验证回文串</a></h4><p>审题。然后有些api忘记了自己实现就好。</p>
<h4 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator/">224. 基本计算器</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s=s.replaceAll(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span>[] sc=s.toCharArray();</span><br><span class="line">        Deque&lt;Integer&gt; numStack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Deque&lt;Character&gt; opsStack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=sc.length;</span><br><span class="line">        numStack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sc[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                opsStack.push(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sc[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> op=opsStack.pop();</span><br><span class="line">                <span class="keyword">while</span>(op!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    calculate(numStack,op);</span><br><span class="line">                    op=opsStack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isDigit(sc[i]))&#123;</span><br><span class="line">                <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;len&amp;&amp;isDigit(sc[i]))&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp=sc[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    u=u*<span class="number">10</span>+temp;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                numStack.push(u);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!opsStack.isEmpty()&amp;&amp;opsStack.peek()!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">char</span> op=opsStack.pop();</span><br><span class="line">                    calculate(numStack,op);</span><br><span class="line">                &#125;</span><br><span class="line">                opsStack.push(sc[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!opsStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">char</span> op=opsStack.pop();</span><br><span class="line">            calculate(numStack,op);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numStack.pop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(Deque&lt;Integer&gt; numStack,<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1=numStack.pop();</span><br><span class="line">        <span class="keyword">int</span> num2=numStack.pop();</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;+&#x27;</span>) numStack.push(num1+num2);</span><br><span class="line">        <span class="keyword">else</span> numStack.push(num2-num1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是要将模拟的情况弄清楚，确保模拟的办法不要出错。</p>
<p>然后自己又犯下的错误是：没有注意到越界的情况，导致了越界；开始模拟的错误是，没有正确模拟，要注意如果平级的字符进去，要先计算。</p>
<p>模拟的要点是根据自己的例子给出方案。关键是大致思路，然后是对细节进行修补改进。解法一定要有逻辑性。</p>
<p>像这道题，就是通过对不同的情况进行一个分类，然后求解。</p>
<p>对于比如对角线遍历的问题，就是自己找规律然后描述规律看如何求解。</p>
<h4 id="394-字符串解码-1"><a href="#394-字符串解码-1" class="headerlink" title="394. 字符串解码"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-string/">394. 字符串解码</a></h4><p>自己开始的解法超出内存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.遇到数字，入栈。</span></span><br><span class="line"><span class="comment">        2.遇到字母，加入StringBuilder.</span></span><br><span class="line"><span class="comment">        3.遇到[将sb加入栈中。</span></span><br><span class="line"><span class="comment">        4.遇到],取出num，对sb repeat，然后将sb和栈内的字母相加。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Deque&lt;Integer&gt; numStack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Deque&lt;String&gt; stringStack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] sc=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len=sc.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isDigit(sc[i]))&#123;</span><br><span class="line">            <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;len&amp;&amp;isDigit(sc[i]))&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=sc[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                u=u*<span class="number">10</span>+temp;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            numStack.push(u);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sc[i]==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                stringStack.push(sb.toString());</span><br><span class="line">                sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sc[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> repeat=numStack.pop();</span><br><span class="line">                StringBuilder temp=<span class="keyword">new</span> StringBuilder(stringStack.pop());</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;repeat;i++)&#123;</span><br><span class="line">                    temp.append(sb);</span><br><span class="line">                &#125;</span><br><span class="line">                sb=temp;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(sc[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;<span class="string">&#x27;0&#x27;</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为K的子数组</a></h4><p>关键点是前缀和的思路，然后是之前要记住put 0。</p>
<p>这里的hash表主要是对比的时候省下时间复杂度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//默认是有0，对应的情况是一个数本身为k</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">int</span> findx=sum-k;</span><br><span class="line">            count=count+map.getOrDefault(findx,<span class="number">0</span>);</span><br><span class="line">            map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="402-移掉-K-位数字"><a href="#402-移掉-K-位数字" class="headerlink" title="402. 移掉 K 位数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-k-digits/">402. 移掉 K 位数字</a></h4><p>这里是是一个非常简单的思路：就是尽量让高位的数尽可能小就行，要多记忆这种想法。</p>
<p>这道题消耗的时间主要是数据结构没搞清楚，开始想用stack来做这个事情，但是实际上由于前导0的存在，还是用双端队列来做比较合适。</p>
<p>这里是用了一个队列来存储，来比较下一个数和队列里面的数的大小，想办法将大的数给去掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=num.length();</span><br><span class="line"></span><br><span class="line">        Deque&lt;Character&gt; deque=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] nc=num.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> digit=nc[i];</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty()&amp;&amp;k&gt;<span class="number">0</span>&amp;&amp;digit&lt;deque.peekLast())&#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="comment">//这里是对高位的数，尽可能让高位的数小</span></span><br><span class="line">            deque.offerLast(digit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;k&gt;<span class="number">0</span>;k--)&#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> seen=<span class="keyword">false</span>;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">char</span> digit=deque.pollFirst();</span><br><span class="line">            <span class="keyword">if</span>(!seen&amp;&amp;digit==<span class="string">&#x27;0&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">            sb.append(digit);</span><br><span class="line">            seen=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.length()&gt;<span class="number">0</span>?sb.toString():<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">442. 数组中重复的数据</a></h4><p>index sort题目，这道题做过，自己忘记了。可以看下面的视频：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1z5411E7Zw?from=search&amp;seid=13427860998490101079">https://www.bilibili.com/video/BV1z5411E7Zw?from=search&amp;seid=13427860998490101079</a></p>
<p>这种题目还是手写一下，搞清楚对应的情况，然后再做比较简单。java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(nums[i]!=i+<span class="number">1</span>&amp;&amp;nums[nums[i]-<span class="number">1</span>]!=nums[i])&#123;</span><br><span class="line">                swap(i,nums[i]-<span class="number">1</span>,nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=i+<span class="number">1</span>)&#123;</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index1,<span class="keyword">int</span> index2,<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[index1];</span><br><span class="line">        nums[index1]=nums[index2];</span><br><span class="line">        nums[index2]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两个链表的第一个公共节点</a></h4><p>做过好多遍了，记忆一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode pa=headA;</span><br><span class="line">        ListNode pb=headB;</span><br><span class="line">        <span class="keyword">while</span>(pa!=pb)&#123;</span><br><span class="line">            pa=(pa==<span class="keyword">null</span>?headB:pa.next);</span><br><span class="line">            pb=(pb==<span class="keyword">null</span>?headA:pb.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="556-下一个更大元素-III"><a href="#556-下一个更大元素-III" class="headerlink" title="556. 下一个更大元素 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-element-iii/">556. 下一个更大元素 III</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] nums=String.valueOf(n).toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">int</span> i=len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]&lt;=nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;len&amp;&amp;nums[j]&gt;nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,i-<span class="number">1</span>,j-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,i);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ans=Integer.parseInt(String.valueOf(nums));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] nums,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp=nums[index1];</span><br><span class="line">        nums[index1]=nums[index2];</span><br><span class="line">        nums[index2]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] nums,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=index;</span><br><span class="line">        <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            swap(nums,left,right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次写leetcode，调试都花了最长的时间。我怀疑其实都是因为开始做题的时候没把答案理解清楚。然后有些点就错了。因此一定要记录错误，因为这些错误就是最耗时间的。</p>
<p>我犯下的错误:</p>
<p>1.下标没有看清楚，然后下标越界。</p>
<p>2，注意合理的过程：</p>
<p>​    首先将左边的小数和右边的大数交换之后，还要对小数之后的数进行一个翻转。这个翻转的下标我一开始弄错了。应该是左边的数的后一位而非右边的数的后一位。把答案理解清楚，慢就是快。</p>
<h4 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></h4><p>首先将步骤给搞清楚，弄明白：</p>
<p>1.明确我们是在哪一步可以确定逆序对的数量，实际上我们是在合并的时候确定逆序对的数量。</p>
<p>2.因此我们写一个函数首先对数组进行分裂与合并。该函数的返回值，就是这一轮的分裂和合并可以确定的逆序对的数量：</p>
<p>在确定参数的时候要想清楚函数里面要做如下的事情：</p>
<p>1.将数组切分成两部分，继续递归调用后面的函数，将子数组排列为有序</p>
<p>2.在得到有序的子数组之后，将两个子数组合并，得到该轮合并可以得到的逆序对的值。</p>
<p>拓展有小和问题：</p>
<p><img src="https://slowsail-gulifile.oss-cn-hangzhou.aliyuncs.com/img/image-20220907205845121.png" alt="image-20220907205845121"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 示例 1: </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 输入: [7,5,6,4]</span></span><br><span class="line"><span class="comment">//输出: 5 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 限制： </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 0 &lt;= 数组长度 &lt;= 50000 </span></span><br><span class="line"><span class="comment">// Related Topics 树状数组 线段树 数组 二分查找 分治 有序集合 归并排序 </span></span><br><span class="line"><span class="comment">// 👍 497 👎 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            copy[i]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">return</span> reversePairs(copy,<span class="number">0</span>,len-<span class="number">1</span>,temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right==left)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;<span class="comment">//这里还是要注意</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftPair = reversePairs(nums,left,mid,temp);</span><br><span class="line">        <span class="keyword">int</span> rightPair = reversePairs(nums,mid+<span class="number">1</span>,right,temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&lt;=nums[mid+<span class="number">1</span>])<span class="keyword">return</span> leftPair+rightPair;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mergeNum=mergeSort(nums,left,right,mid,temp);</span><br><span class="line">        <span class="keyword">return</span> mergeNum+leftPair+rightPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> mid,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            temp[i]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面的过程是通过递归的方式，对temp进行排序，每次挑选出两边的最小值到num中</span></span><br><span class="line">        <span class="comment">//一共是四种情况，包括左边排完了，右边排完了，然后还有左边小，右边小</span></span><br><span class="line">        <span class="keyword">int</span> i=left;</span><br><span class="line">        <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=left;k&lt;=right;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==mid+<span class="number">1</span>)&#123;</span><br><span class="line">                nums[k]=temp[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==right+<span class="number">1</span>)&#123;</span><br><span class="line">                nums[k]=temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp[i]&lt;=temp[j])&#123;</span><br><span class="line">                nums[k]=temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[k]=temp[j];</span><br><span class="line">                j++;</span><br><span class="line">                count+=mid-i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>回顾自己的代码，出现最大错误的原因是在遍历的时候边界没有自己敲，然后自动补全让自己错误了。注意边界条件，注意==。</p>
<h4 id="394-字符串解码-2"><a href="#394-字符串解码-2" class="headerlink" title="394. 字符串解码"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-string/">394. 字符串解码</a></h4><p>思路其实一直很简单，但是之前不知道为啥一直报错。</p>
<p>先把整体的思路写一写。</p>
<p>这里遇到不同的字符对应不同的操作：</p>
<p>1.数字：将数字整体当成字符串存入。</p>
<p>2.字符和[:作为字符串存入即可。</p>
<p>3.]:当遇到]的时候：</p>
<p>​    先将里面的所有字符取出合并成一个字符串，注意要逆序一下。</p>
<p>​    然后将数字取出，得到repeat的次数。</p>
<p>​    根据repeat的次数将字符串repeat生成新的字符。</p>
<p>​    放入栈中。</p>
<p>4.最后将栈中元素全部取出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ptr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; stk = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(ptr);</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(cur)) &#123;</span><br><span class="line">                <span class="comment">// 获取一个数字并进栈</span></span><br><span class="line">                String digits = getDigits(s);</span><br><span class="line">                stk.addLast(digits);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isLetter(cur) || cur == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取一个字母并进栈</span></span><br><span class="line">                stk.addLast(String.valueOf(s.charAt(ptr++))); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                LinkedList&lt;String&gt; sub = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">                <span class="keyword">while</span> (!<span class="string">&quot;[&quot;</span>.equals(stk.peekLast())) &#123;</span><br><span class="line">                    sub.addLast(stk.removeLast());</span><br><span class="line">                &#125;</span><br><span class="line">                Collections.reverse(sub);</span><br><span class="line">                <span class="comment">// 左括号出栈</span></span><br><span class="line">                stk.removeLast();</span><br><span class="line">                <span class="comment">// 此时栈顶为当前 sub 对应的字符串应该出现的次数</span></span><br><span class="line">                <span class="keyword">int</span> repTime = Integer.parseInt(stk.removeLast());</span><br><span class="line">                StringBuffer t = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                String o = getString(sub);</span><br><span class="line">                <span class="comment">// 构造字符串</span></span><br><span class="line">                <span class="keyword">while</span> (repTime-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    t.append(o);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将构造好的字符串入栈</span></span><br><span class="line">                stk.addLast(t.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getString(stk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDigits</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer ret = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (Character.isDigit(s.charAt(ptr))) &#123;</span><br><span class="line">            ret.append(s.charAt(ptr++));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(LinkedList&lt;String&gt; v)</span> </span>&#123;</span><br><span class="line">        StringBuffer ret = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (String s : v) &#123;</span><br><span class="line">            ret.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>晚上还是把结果写出来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.因为包含括号的嵌套，因此考虑使用栈来解决该问题</span></span><br><span class="line"><span class="comment">        2.对于数字，直接入栈（字符串形式进去）</span></span><br><span class="line"><span class="comment">        3.对于[,入栈</span></span><br><span class="line"><span class="comment">        4.对于字符，入栈。</span></span><br><span class="line"><span class="comment">        5.对于]</span></span><br><span class="line"><span class="comment">            开始出栈，出栈的元素累积成字符串直到[为止，然后反转</span></span><br><span class="line"><span class="comment">            然后数字出栈，然后repeat然后放入栈中和前面的元素连接</span></span><br><span class="line"><span class="comment">            最后总的字符串出栈</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line"></span><br><span class="line">        Deque&lt;String&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isDigit(s.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;len&amp;&amp;isDigit(s.charAt(i)))&#123;</span><br><span class="line">                    u=u*<span class="number">10</span>+s.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(String.valueOf(u));</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">while</span>(!<span class="string">&quot;[&quot;</span>.equals(stack.peek()))&#123;</span><br><span class="line">                    sb.insert(<span class="number">0</span>,stack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">int</span> num=Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">                    stack.push(sb.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(s.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            sb.insert(<span class="number">0</span>,stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>犯下的错误：</p>
<p>1.局部循环量名字冲突。for i 内部循环变量名字写成一样了，低级错误。</p>
<p>2.注意栈的类型</p>
<p>3.<strong>坑了自己很久，就是String的比较要用equals不要用==</strong></p>
<h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h4><p>一道非常弱智的题目，这里用一个队列实现了栈。</p>
<p>每次在push的时候操作，每次push元素的时候，将前面的元素poll出来然后放在队尾，相当于对于每一个push到队列中的元素，都把当前push的这个元素放到队首。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=queue.size();</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            size--;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>这里犯下的错误是之前的初始化代码和声明冲突，这完全就是不小心引起的错误。</p>
<h4 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="443. 压缩字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/string-compression/">443. 压缩字符串</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.双指针遍历</span></span><br><span class="line"><span class="comment">            rPoint 0 开始指向读取的位置</span></span><br><span class="line"><span class="comment">            wPoint 0 开始指向写的位置</span></span><br><span class="line"><span class="comment">        2.读取的时候要做的事情：</span></span><br><span class="line"><span class="comment">            记录当前的字符</span></span><br><span class="line"><span class="comment">            记录当前的数字</span></span><br><span class="line"><span class="comment">        3.写的时候要做的事情</span></span><br><span class="line"><span class="comment">            写对应的字符</span></span><br><span class="line"><span class="comment">            写对应的数字</span></span><br><span class="line"><span class="comment">        4.外层的大循环是读指针遍历字符数组</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rPoint=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> wPoint=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=chars.length;</span><br><span class="line">        <span class="keyword">while</span>(rPoint&lt;len)&#123;</span><br><span class="line">            <span class="keyword">char</span> cur=chars[rPoint];</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(rPoint&lt;len&amp;&amp;cur==chars[rPoint])&#123; <span class="comment">//指针问题边界错误，拼写错误</span></span><br><span class="line">                count++;</span><br><span class="line">                rPoint++;</span><br><span class="line">            &#125;</span><br><span class="line">            chars[wPoint++]=cur;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> ch:(<span class="string">&quot;&quot;</span>+count).toCharArray())&#123;<span class="comment">//另外注意这个首先转字符串然后转数组的方法</span></span><br><span class="line">                chars[wPoint++]=ch;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wPoint;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h4><p>思路如下：</p>
<p>1.定义两个指针，其中一个指向0要放入的位置，一个指向2要放入的位置。</p>
<p>2.定义一个i，i遍历到point2就结束循环。</p>
<p>3.如果nums[i]==0，交换point0和nums[i]的位置。point0++,i++。因为这里point0肯定已经被遍历过了，所以只需要检测一次。</p>
<p>4.如果nums[i]=2，交换point2和nums[i]的位置。point2–，i++。但是注意这个时候的point2是没有做检查的，因此需要继续判断nums[i]的情况，如果是2则继续4，如果是0则继续3。</p>
<p><strong>答案的程序的运行结构设计非常巧妙。while+if的判断。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> point0=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">int</span> point2=len-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=point2;i++)&#123;<span class="comment">//凡是指针问题，一定要关注边界</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;=point2&amp;&amp;nums[i]==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=nums[point2];</span><br><span class="line">                nums[point2]=nums[i];</span><br><span class="line">                nums[i]=temp;</span><br><span class="line">                point2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=nums[point0];</span><br><span class="line">                nums[point0]=nums[i];</span><br><span class="line">                nums[i]=temp;</span><br><span class="line">                point0++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></h4><p>下面是快速排序的一个笔记：</p>
<p>快速排序的步骤：</p>
<p>1.找出数组的左边界右边界，调用quickSort函数。</p>
<p>2.在quickSort函数里面调用partition函数，该函数可以将一个元素放置到应该放置的位置，然后返回该元素的位置。</p>
<p>3.利用partition生成的边界，确定下一轮quickSort的位置，递归调用。</p>
<p>4.partition做的事情是：</p>
<p>​        1.选择一个为基准。</p>
<p>​        2.遍历数组。</p>
<p>​        3.对于比基准大的，不管；对于比基准小的将其交换到小指针所指向的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)</span><br><span class="line"></span><br><span class="line">谈谈我的思路过程。</span><br><span class="line"></span><br><span class="line">看到题目的时候，我就在想是否可以用动态规划，然后参考了一下之前做过的[<span class="number">198.</span> 打家劫舍](https:<span class="comment">//leetcode-cn.com/problems/house-robber/)。198是道典型的动态规划题目，两道题其实都挺像，就是说上一层的选择对下一层有影响。</span></span><br><span class="line"></span><br><span class="line"><span class="number">198</span>题之所以可以用动态规划，是因为每一个点的值，都是可以由前面两个点的值决定的，而前面两个点的值也是由其前方值决定的。所以虽然看起来我们有很多的选，**但是实际上一切都是注定的，利用表格就可以将动态规划的值给表示出来。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这道三角形的题目，无非是由线性的线段点变成了二维数组而已，实际上还是一样的，只需要将每个点的最优解标注出来，那么所有的最优解都得到了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**人生也是如此。因为我们的每一个下一次的选择，都依赖于当前的选择，因此，贪心算法是合适的。不用畏惧小概率事件，就在当前的节点出发，争取在每个时间节点获得最优解，那么就可以得到人生的最优解。**</span><br><span class="line"></span><br><span class="line">当然，人生的难点在于，我们在一个时间点上，很难有超出该时间点的认识水平，以至于无法对自己当时的选择进行评估。但是，**我相信如果能克服自己的懒惰，努力做到现有认识水平的最优解，至少不会太过于倒霉吧。**</span><br><span class="line"></span><br><span class="line">代码如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.f[i][j]=Math.min(f[i-1][j-1],f[i-1][j])+triangle.get(i).get(j)</span></span><br><span class="line"><span class="comment">        2.注意，上面的式子有一些特殊情况要考虑：</span></span><br><span class="line"><span class="comment">            1.0 0 =triangle.get(0).get(0)</span></span><br><span class="line"><span class="comment">            2.i=j的时候，j越界，因此j&lt;i  注意这里的f[i-1][j]越界，所以这个式子要单独写</span></span><br><span class="line"><span class="comment">            3.上层结束后才可以到下层，因此需要按i遍历</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> row=triangle.size();</span><br><span class="line">        <span class="keyword">int</span>[][] f=<span class="keyword">new</span> <span class="keyword">int</span>[row][row];</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            f[i][<span class="number">0</span>]=f[i-<span class="number">1</span>][<span class="number">0</span>]+triangle.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">                f[i][j]=Math.min(f[i-<span class="number">1</span>][j-<span class="number">1</span>],f[i-<span class="number">1</span>][j])+triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][i]=f[i-<span class="number">1</span>][i-<span class="number">1</span>]+triangle.get(i).get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;row;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(min&gt;f[row-<span class="number">1</span>][j])min=f[row-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.这道题也是数组问题，因此需要判断边界。</p>
<p>2.注意观察数组形状，不用求col。</p>
<p>3.get方法。</p>
<h4 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h4><p>很累，精神状态不算好，写题写得辛苦。</p>
<p>仍然是注意下标的问题。首先是快排记得实在不是很清楚，必须反复记忆。然后是忘记了取==。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        String[] sA=<span class="keyword">new</span> String[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            sA[i]=String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        quickSort(sA,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s:sA)&#123;</span><br><span class="line">            res.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(String[] sA,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot=partition(sA,left,right);</span><br><span class="line">        quickSort(sA,left,pivot-<span class="number">1</span>);</span><br><span class="line">        quickSort(sA,pivot+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String[] sA,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        String pivot=sA[left];</span><br><span class="line">        <span class="keyword">int</span> swapP=left;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((pivot+sA[i]).compareTo(sA[i]+pivot)&gt;<span class="number">0</span>)<span class="comment">//定义如果比pivot小，那么就放到前面，如果比pivot大++</span></span><br><span class="line">            &#123;</span><br><span class="line">                swapP++;</span><br><span class="line">                swap(sA,swapP,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(sA,left,swapP);</span><br><span class="line">        <span class="keyword">return</span> swapP;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.将pivot和后面的指针比较，</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String[] sA,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        String temp=sA[index1];</span><br><span class="line">        sA[index1]=sA[index2];</span><br><span class="line">        sA[index2]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 如果长度不够，不搜索</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">4</span> || len &gt; <span class="number">12</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;String&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span> splitTimes = <span class="number">0</span>;</span><br><span class="line">        dfs(s, len, splitTimes, <span class="number">0</span>, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断 s 的子区间 [left, right] 是否能够成为一个 ip 段</span></span><br><span class="line"><span class="comment">     * 判断的同时顺便把类型转了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">judgeIfIpSegment</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大于 1 位的时候，不能以 0 开头</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">1</span> &amp;&amp; s.charAt(left) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转成 int 类型</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &gt; <span class="number">255</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> len, <span class="keyword">int</span> split, <span class="keyword">int</span> begin, Deque&lt;String&gt; path, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (split == <span class="number">4</span>) &#123;</span><br><span class="line">                res.add(String.join(<span class="string">&quot;.&quot;</span>, path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//跳出条件：如果已经遍历结束，并且有4段，那么就将path连接成字符串存入res</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 看到剩下的不够了，就退出（剪枝），len - begin 表示剩余的还未分割的字符串的位数</span></span><br><span class="line">        <span class="keyword">if</span> (len - begin &lt; (<span class="number">4</span> - split) || len - begin &gt; <span class="number">3</span> * (<span class="number">4</span> - split)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin + i &gt;= len) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//对于每一个起点，考虑三种情况，就是接下来一段是1,2,3的三种情况</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ipSegment = judgeIfIpSegment(s, begin, begin + i);</span><br><span class="line">            <span class="keyword">if</span> (ipSegment != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 在判断是 ip 段的情况下，才去做截取</span></span><br><span class="line">                path.addLast(ipSegment + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                dfs(s, len, split + <span class="number">1</span>, begin + i + <span class="number">1</span>, path, res);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的整体思路：</p>
<p>​    1.对长度做一个大概的判断，如果离谱直接返回。</p>
<p>​    2.建立dfs函数，进行遍历：</p>
<p>​            首先判断是否到了退出条件：已经到了结尾且分段数符合要求</p>
<pre><code>         其次从当前点开始，分别以1,2,3位长度进行分段</code></pre>
<p>​            对分段进行判断，要求分段合理</p>
<p>​            如果分段合理，那么就将该答案放入path，并进行下一轮dfs</p>
<p>自己写的答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">4</span>||len&gt;<span class="number">12</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;String&gt; path=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(res,s,<span class="number">0</span>,<span class="number">0</span>,path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; res,String s,<span class="keyword">int</span> splitTime,<span class="keyword">int</span> begin,Deque&lt;String&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        <span class="keyword">if</span>(splitTime==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(begin==len)&#123;</span><br><span class="line">                res.add(String.join(<span class="string">&quot;.&quot;</span>,path));</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(len-begin&lt;<span class="number">4</span>-splitTime||len-begin&gt;<span class="number">3</span>*(<span class="number">4</span>-splitTime))<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;begin+<span class="number">3</span>&amp;&amp;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans=isValidIp(s,begin,i);</span><br><span class="line">            <span class="keyword">if</span>(ans==-<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            path.addLast(ans+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            dfs(res,s,splitTime+<span class="number">1</span>,i+<span class="number">1</span>,path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isValidIp</span><span class="params">(String s,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end-begin&gt;<span class="number">0</span>&amp;&amp;s.charAt(begin)==<span class="string">&#x27;0&#x27;</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;=end;i++)&#123;</span><br><span class="line">            count=count*<span class="number">10</span>+s.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">255</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自己写的需要注意的是：</p>
<p>1.记住及时传入参数，比如String 的长度。</p>
<p>2.这里ArrayDeque的用法,这里使用了addLast和removeLast。</p>
<p>3.String.join(“.”,path)</p>
<h4 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h4><p>宽度优先搜索算法：</p>
<p>官方的参考题解：</p>
<p>1.建立一个新的数据结构的队列。</p>
<p>2.将root作为第一个新的数据结构的种子加入队列。</p>
<p>3.在队列不空的情况下</p>
<p>​    弹出队列的节点</p>
<p>​    分别以节点的左右节点作为种子生成新的节点并添加入队列</p>
<p>​    这里要用一个深度值来记录保证每进入下一层，都可以记录下一层节点的left值，然后在每一次取出节点的时候都计算一遍宽度，求出最长的宽度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;AnnotatedNode&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        queue.add(<span class="keyword">new</span> AnnotatedNode(root, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> curDepth = <span class="number">0</span>, left = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            AnnotatedNode a = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (a.node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> AnnotatedNode(a.node.left, a.depth + <span class="number">1</span>, a.pos * <span class="number">2</span>));</span><br><span class="line">                queue.add(<span class="keyword">new</span> AnnotatedNode(a.node.right, a.depth + <span class="number">1</span>, a.pos * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (curDepth != a.depth) &#123;</span><br><span class="line">                    curDepth = a.depth;</span><br><span class="line">                    left = a.pos;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(ans, a.pos - left + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotatedNode</span> </span>&#123;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="keyword">int</span> depth, pos;</span><br><span class="line">    AnnotatedNode(TreeNode n, <span class="keyword">int</span> d, <span class="keyword">int</span> p) &#123;</span><br><span class="line">        node = n;</span><br><span class="line">        depth = d;</span><br><span class="line">        pos = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/maximum-width-of-binary-tree/solution/er-cha-shu-zui-da-kuan-du-by-leetcode/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>下面是我的答案如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;myNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> myNode(<span class="number">0</span>,root));</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size=queue.size();</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                myNode node=queue.poll();   </span><br><span class="line">                TreeNode treeNode=node.node;</span><br><span class="line">                <span class="keyword">int</span> position=node.position;</span><br><span class="line">                <span class="keyword">if</span>(treeNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    list.add(position);</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> myNode(position*<span class="number">2</span>+<span class="number">1</span>,treeNode.left));</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> myNode(position*<span class="number">2</span>+<span class="number">2</span>,treeNode.right));</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(list.size()&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">                max=Math.max(max,list.get(list.size()-<span class="number">1</span>)-list.get(<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">myNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> position;</span><br><span class="line">        TreeNode node;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">myNode</span><span class="params">(<span class="keyword">int</span> position,TreeNode node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.position=position;</span><br><span class="line">            <span class="keyword">this</span>.node=node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>犯下的错误：</p>
<p>1.首先是要注意队列里面存的是自己的myNode，因此如果要判断空的话，应该判断myNode的node属性是否为空。</p>
<p>2.其次是出现数组，arraylist这种，就一定要看是否会越界。</p>
<p>3.&gt;=号的抉择，一定要弄清楚解题的范围。</p>
<h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h4><p>经典tok 问题，不要只满足于堆排序。</p>
<p>还有一个用快排来解题的思路，可以看这道题：</p>
<h4 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h4><p>此题有两个坑点。一个是注意第K个<strong>最大</strong>元素，所以之前要将k计算出来交换位置。</p>
<p>另外一个是一定要将快排记忆熟练，记清楚分界指针是什么时候什么条件下移动的。</p>
<p>参考代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.每次都用partition方法确定一个元素的位置，根据这个元素的位置更换区间。</span></span><br><span class="line"><span class="comment">        2. int index=partition(0,nums.length);</span></span><br><span class="line"><span class="comment">        3.if(index==k)return nums[k];</span></span><br><span class="line"><span class="comment">          if(index&lt;k) partition(index+1,nums.length);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        k=nums.length-k;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> index=partition(nums,left,right);</span><br><span class="line">            <span class="keyword">if</span>(index==k)<span class="keyword">return</span> nums[k];</span><br><span class="line">            <span class="keyword">if</span>(index&lt;k) left=index+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(index&gt;k) right=index-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right&gt;left)&#123;</span><br><span class="line">        Random rand=<span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> index=left+rand.nextInt(right-left+<span class="number">1</span>);</span><br><span class="line">        swap(nums,left,index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivot=nums[left];</span><br><span class="line">        <span class="keyword">int</span> swapI=left;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;pivot)&#123;</span><br><span class="line">                swapI++;</span><br><span class="line">                swap(nums,swapI,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,swapI,left);</span><br><span class="line">        <span class="keyword">return</span> swapI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[left];</span><br><span class="line">        nums[left]=nums[right];</span><br><span class="line">        nums[right]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></h4><p>首先根据题意简单写了一个回溯的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.返回方法的总数：想到了回溯的解法。</span></span><br><span class="line"><span class="comment">        先按照回溯写一写吧</span></span><br><span class="line"><span class="comment">        2.回溯返回的条件：已经将s遍历完毕</span></span><br><span class="line"><span class="comment">        3.回溯描述：</span></span><br><span class="line"><span class="comment">            1.遍历s</span></span><br><span class="line"><span class="comment">            2.以当前字符或者当前字符的下一位为基准，判断是否有效，有效则继续，无效则放弃。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">        dfs(s,<span class="number">0</span>,len);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s,<span class="keyword">int</span> begin,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin==len)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(begin)!=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        dfs(s,begin+<span class="number">1</span>,len);</span><br><span class="line">        <span class="keyword">if</span>(isValid(s,begin,begin+<span class="number">1</span>))&#123;</span><br><span class="line">            dfs(s,begin+<span class="number">2</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end&gt;=s.length())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> num=(s.charAt(begin)-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+s.charAt(end)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;=<span class="number">10</span>&amp;&amp;num&lt;=<span class="number">26</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是发现超时。</p>
<p>然后还有一些其他问题：</p>
<p>1.比如说发现’0’是没有对应编码的，这个自己要注意审题，不要弄错。</p>
<p>但是上面的方法是会超时的，因此考虑动态规划的想法。</p>
<p>这种类型的动态规划的想法其实就是递归的想法。假设知道前面的解的答案，从而得到后面的解的答案：</p>
<p>1.对于i位置而言，i位置可能对应的字符串的个数为：</p>
<p>​    1.考虑i位置对应1个字符的情况：</p>
<p>​        如果i位置不是’0’，那么f_i=f_i-1</p>
<p>​    2.考虑i位置对应2个字符的情况：</p>
<p>​        如果i-1–i符合条件，那么f_i=f_i-2</p>
<p>依据上面式子列写方程即可。</p>
<h4 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297. 二叉树的序列化与反序列化"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h4><p>试着写一下思路：</p>
<p>1.序列化的思路：</p>
<p>​    1.通过dfs遍历每一个节点。</p>
<p>​    2.如果遇到普通的值，那么就将该值作为字符串存入列表中；如果是null，则存入null字段。这里注意，为了区分数字和数字之间，每个字符串要用,连接。</p>
<p>2.反序列化的思路：</p>
<p>​    1.对于上面得到的字符串，以,为单位分割为数组。</p>
<p>​    2.然后遍历数组每次将list(0)作为root节点对应的值，然后remove，然后利用递归的方式将list传入，这里同样遵循先序的原则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rserialize(root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String[] dataArray = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        List&lt;String&gt; dataList = <span class="keyword">new</span> LinkedList&lt;String&gt;(Arrays.asList(dataArray));<span class="comment">//记住这个api</span></span><br><span class="line">        <span class="keyword">return</span> rdeserialize(dataList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rserialize</span><span class="params">(TreeNode root, String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            str += <span class="string">&quot;None,&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str += str.valueOf(root.val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">            str = rserialize(root.left, str);</span><br><span class="line">            str = rserialize(root.right, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">rdeserialize</span><span class="params">(List&lt;String&gt; dataList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataList.get(<span class="number">0</span>).equals(<span class="string">&quot;None&quot;</span>)) &#123;</span><br><span class="line">            dataList.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(dataList.get(<span class="number">0</span>)));</span><br><span class="line">        dataList.remove(<span class="number">0</span>);</span><br><span class="line">        root.left = rdeserialize(dataList);</span><br><span class="line">        root.right = rdeserialize(dataList);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>不知道为啥按下面写的超时，也不难诶，今天状态不太行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb=rserialize(root,sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">rserialize</span><span class="params">(TreeNode root,StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;NULL,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sb;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(String.valueOf(root.val)+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        sb=rserialize(root.left,sb);</span><br><span class="line">        sb=rserialize(root.right,sb);</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String[] str=data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(str));</span><br><span class="line">        TreeNode node=rdeserialize(list);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode  <span class="title">rdeserialize</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.get(<span class="number">0</span>).equals(<span class="string">&quot;NULL&quot;</span>))&#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(Integer.valueOf(list.get(<span class="number">0</span>)));<span class="comment">//思路不清晰了，这里要记得移除0</span></span><br><span class="line">        root.left=rdeserialize(list);</span><br><span class="line">        root.right=rdeserialize(list);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>







<h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h4><p>看下这道题的思路：</p>
<p>kmp以后再说吧。</p>
<p>比如说有一个字符串：abcabc</p>
<p>发现如果移动这个字符串的话：bcabca   cabcab abcabc </p>
<p>想要出现上述组合的话，一种方式是像上面一样逐次移动字符串，另外一种方式的而话，是通过拼接的方式组合字符串，那么所谓的移动，其实就会在其中出现了。</p>
<p>比如 abcabc+abcabc=abcabcabcabc</p>
<p>其中是会包含一个abcabc的，因为其中从第3位开始相当于移动了3位。</p>
<p>因此，java的一行代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (s+s).indexOf(s,<span class="number">1</span>)!=s.length();</span><br></pre></td></tr></table></figure>



<p>这里注意一下，因为这里有两个s相加，因此，其肯定是存在s的，因此在s.length()的位置一定可以找到匹配的字符串。这里只有在前面存在字符串的时候，返回值才不是s.length()。</p>
<h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a></h4><p>思路：</p>
<p>以nums = [2,3,1,1,4]为例子。</p>
<p>这里：</p>
<p>nums[0]: 1,2           记录max=2</p>
<p>nums[1]:2,3,4</p>
<p>nums[2]:3</p>
<p>nums[3]:4</p>
<p>nums[4] over</p>
<p><strong>思路就是每个点更新可以去的最大值，然后如果i没有到达最大值就更新。</strong></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxPosition=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nums.length&amp;&amp;i&lt;=maxPosition)&#123;</span><br><span class="line">            maxPosition=Math.max(maxPosition,nums[i]+i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==nums.length)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里犯下的错误：</p>
<p>1.注意&lt;=符号要搞清楚意义。</p>
<p>2.记得任何数组相关问题不要越界。</p>
<h4 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445. 两数相加 II</a></h4><p>有了思路以后其实就还比较简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.建立两个栈，将链表节点的值放在栈中。</span></span><br><span class="line"><span class="comment">        2.对两个栈进行出栈操作</span></span><br><span class="line"><span class="comment">        出栈的数进行运算，更新进位，注意这里循环条件也包括一个对进位的判断</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Deque&lt;Integer&gt; stack1=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack2=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        ListNode point1=l1;</span><br><span class="line">        ListNode point2=l2;</span><br><span class="line">        <span class="keyword">while</span>(point1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack1.push(point1.val);</span><br><span class="line">            point1=point1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(point2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack2.push(point2.val);</span><br><span class="line">            point2=point2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">        ListNode head=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty()||!stack2.isEmpty()||cur!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1=stack1.isEmpty()?<span class="number">0</span>:stack1.pop();</span><br><span class="line">            <span class="keyword">int</span> num2=stack2.isEmpty()?<span class="number">0</span>:stack2.pop();</span><br><span class="line">            <span class="keyword">int</span> ans=num1+num2+cur;</span><br><span class="line">            cur=ans/<span class="number">10</span>;</span><br><span class="line">            ans=ans%<span class="number">10</span>;</span><br><span class="line">            head.next=<span class="keyword">new</span> ListNode(ans,head.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是要注意哈，这里犯了一个傻逼错误，三元表示多打了一个冒号。</p>
<p>然后这里有一个已经声明的量又声明了一遍。</p>
<h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a></h4><p>这里假设机器人的坐标是i,j。由于每次只能向下或者向右移动一步。因此，下一轮坐标是</p>
<p>i+1,j  或者i,j+1。因此</p>
<p>如果想到达i,j 那么可以是i-1,j点也可以是i,j-1点到达。</p>
<p>所以可以给出递推式子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i][j]=f[i-<span class="number">1</span>][j]+f[i][j-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>这里要注意一下：</p>
<p>1.i和j的边界。当i=0时,j=0时。</p>
<p>2.当</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obstacleGrid[i][j]=<span class="number">0</span>时</span><br><span class="line">此时f[i][j]=<span class="number">0</span></span><br></pre></td></tr></table></figure>



<h4 id="405-数字转换为十六进制数"><a href="#405-数字转换为十六进制数" class="headerlink" title="405. 数字转换为十六进制数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">405. 数字转换为十六进制数</a></h4><p>这道题的思路是首先将数字转换为二进制表示（不用转换，其实只要用位运算默认就是二进制），然后每4位二进制数进行一个转换。四位二进制数刚好对应的就是10进制的1-15，所以写一个数组，然后数组完成这样的一个映射即可。</p>
<p>逻辑上设计用while循环来做这个事情，当num为0的时候循环结束，每次取num的低位，然后num要记得右移。</p>
<p>这里要注意一下对负数的处理，因为都表示成二进制了，所以直接就转换成十六进制即可。然后记住循环终止条件不能写错成num&gt;0。因为num可能是负数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)<span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;<span class="comment">//注意这里的特殊值处理</span></span><br><span class="line">        <span class="keyword">char</span>[] table=<span class="string">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> count=num&amp;<span class="number">0xf</span>;</span><br><span class="line">            sb.insert(<span class="number">0</span>,table[count]);</span><br><span class="line">            num&gt;&gt;&gt;=<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="384. 打乱数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shuffle-an-array/">384. 打乱数组</a></h4><p>洗牌算法的一个很好的解释：</p>
<h4 id="https-www-zhihu-com-search-q-E6-B4-97-E7-89-8C-E7-AE-97-E6-B3-95-amp-type-content"><a href="#https-www-zhihu-com-search-q-E6-B4-97-E7-89-8C-E7-AE-97-E6-B3-95-amp-type-content" class="headerlink" title="https://www.zhihu.com/search?q=%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95&amp;type=content"></a><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95&amp;type=content">https://www.zhihu.com/search?q=%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95&amp;type=content</a></h4><p> 官方解法给出了下面的一个暴力答案：</p>
<p>1.solution里面传入原始的数组，这里要用array指向原始的数组，然后克隆一份origin数组以后备用。</p>
<p>2.reset里面要将array指向origin数组，然后orgin数组指向自己的克隆。</p>
<p>3.shuffle函数首先要得到一个拷贝数组的列表，然后要从列表中随机挑选数放到array的数组中；这里随机的下标的选择方式为rand.nextInt(aux.size())。这个函数的含义是可以随机生成0-aux.size()-1范围的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] original;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getArrayCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; asList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            asList.add(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> asList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        array = nums;</span><br><span class="line">        original = nums.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        array = original;</span><br><span class="line">        original = original.clone();</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        List&lt;Integer&gt; aux = getArrayCopy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> removeIdx = rand.nextInt(aux.size());</span><br><span class="line">            array[i] = aux.get(removeIdx);</span><br><span class="line">            aux.remove(removeIdx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有一个洗牌算法的答案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] original;</span><br><span class="line"></span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randRange</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rand.nextInt(max - min) + min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapAt</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        array = nums;</span><br><span class="line">        original = nums.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        array = original;</span><br><span class="line">        original = original.clone();</span><br><span class="line">        <span class="keyword">return</span> original;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            swapAt(i, randRange(i, array.length));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实洗牌算法就是一句话，就是在for循环内部，交换i和i之后的元素。</p>
<p>当然，也可以反方向，反方向的实现随机数就更简单。</p>
<p>就是第一轮是0–n-1 </p>
<p>然后是0-n-2</p>
<p>0-n-3 这样的交换。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] origin;</span><br><span class="line">    <span class="keyword">private</span> Random rand=<span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        arr=nums;</span><br><span class="line">        origin=nums.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Resets the array to its original configuration and return it. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        arr=origin;</span><br><span class="line">        origin=origin.clone();</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns a random shuffling of the array. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           swap(i,rand.nextInt(i+<span class="number">1</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[index1];</span><br><span class="line">        arr[index1]=arr[index2];</span><br><span class="line">        arr[index2]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * int[] param_1 = obj.reset();</span></span><br><span class="line"><span class="comment"> * int[] param_2 = obj.shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>注意数组到底的api是length。</p>
<h4 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] indegrees = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacency = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">            adjacency.add(<span class="keyword">new</span> ArrayList&lt;&gt;()); <span class="comment">//每一个课程都建立一个链表</span></span><br><span class="line">        <span class="comment">// Get the indegree and adjacency of every course.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] cp : prerequisites) &#123; <span class="comment">//依赖表</span></span><br><span class="line">            indegrees[cp[<span class="number">0</span>]]++;    <span class="comment">//</span></span><br><span class="line">            adjacency.get(cp[<span class="number">1</span>]).add(cp[<span class="number">0</span>]);<span class="comment">//链表里记录的是这个课程对应的课程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get all the courses with the indegree of 0.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">            <span class="keyword">if</span>(indegrees[i] == <span class="number">0</span>) queue.add(i);<span class="comment">//先将入度为0的入队</span></span><br><span class="line">        <span class="comment">// BFS TopSort.</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> pre = queue.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> cur : adjacency.get(pre))<span class="comment">//对邻接表的每一个元素，都可以减去一个入度</span></span><br><span class="line">                <span class="keyword">if</span>(--indegrees[cur] == <span class="number">0</span>) queue.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;<span class="comment">//最后应该所有的入度为0，即所有课程都入队并出队了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>思路解析：</p>
<p>1.首先建立一个数组，这个数组维持的是每一个节点的入度。初始为0</p>
<p>2然后建立一个二维数组，即List&lt;List<Integer>&gt; 结构。</p>
<p>3.遍历题目中提供的   prerequisites二维数组。</p>
<p>对于每一个子数组，都ch[0]表示的是要修的课程，在对应的入度表中更新。而ch[1]表示的是需要先修的课程，在链表中对应添加ch[0]。</p>
<p>4.当上述二维数组和一维数组建立完毕，将入度为0的课程编号加入链表，然后对于当前的节点，找到二维数组对应的课程，然后把入度表的相应值减1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.创建一个数组，记录入度。</span></span><br><span class="line"><span class="comment">        2.创建一个二维的列表，记录节点。</span></span><br><span class="line"><span class="comment">        3.维持一个队列，将入度为0的节点入队，然后遍历入队。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        这里0-1表示1是0的一个入度，因此0-1是添加序号为1的列表</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span>[] record=<span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;());<span class="comment">//注意这里的arraylist是如何声明定义</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] ch:prerequisites)&#123;</span><br><span class="line">            record[ch[<span class="number">0</span>]]++;</span><br><span class="line">            list.get(ch[<span class="number">1</span>]).add(ch[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(record[i]==<span class="number">0</span>)queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> num=queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> course:list.get(num))&#123;</span><br><span class="line">                record[course]--;</span><br><span class="line">                <span class="keyword">if</span>(record[course]==<span class="number">0</span>)queue.offer(course);</span><br><span class="line">            &#125;</span><br><span class="line">            numCourses--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numCourses==<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面的解法有样例通不过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           1. prerequisites[1]------&gt;[0]</span></span><br><span class="line"><span class="comment">           2.建立一个list&lt;list&gt; 用来维护每一个节点的出度，比如说pre[1] 就添加pre[0]</span></span><br><span class="line"><span class="comment">           每添加一个出度，就在对应的节点（[0]）的计数数组里加1</span></span><br><span class="line"><span class="comment">           3.维护一个队列，用来装所有入度为0的节点，实时更新。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] count=<span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里如何将pre数组的内容更新到链表里面去卡住了，这里的策略是初始化和更新严格分开</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] pre:prerequisites)&#123;</span><br><span class="line">            count[pre[<span class="number">0</span>]]++;</span><br><span class="line">            list.get(pre[<span class="number">1</span>]).add(pre[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i]==<span class="number">0</span>)queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> num=queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> pre0:list.get(num))&#123;</span><br><span class="line">                count[pre0]--;</span><br><span class="line">                <span class="keyword">if</span>(count[pre0]==<span class="number">0</span>)queue.offer(pre0);<span class="comment">//怎么犯下这种低级错误呢，明明是pre0很明显的，然后写成了count[pre0].</span></span><br><span class="line">            &#125;</span><br><span class="line">            numCourses--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.挑选出第一个数，直到第一个数不是0；</span></span><br><span class="line"><span class="comment">        同时，如果第一个数是0的话，count++；</span></span><br><span class="line"><span class="comment">        2.当挑选出第一个非0数的时候，count++，同时可以求出以该点为基准的max min</span></span><br><span class="line"><span class="comment">        3.继续挑数，如果新的数在上面范围内，count++，同时根据新的数求出改点的记住 max min</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">13</span>;</span><br><span class="line">        <span class="keyword">int</span> min=<span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&lt;=max&amp;&amp;nums[i]&gt;=min&amp;&amp;!set.contains(nums[i]))&#123;</span><br><span class="line">                    max=Math.min(nums[i]+<span class="number">4</span>,max);</span><br><span class="line">                    min=Math.max(nums[i]-<span class="number">4</span>,min);</span><br><span class="line">                    set.add(nums[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>犯下的错误：</p>
<p>1.set应该用add方法。</p>
<p>2.注意这里的max和min自己要想清楚怎么调整，然后==的边界情况注意。</p>
<h4 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h4><p>liweiwei的题解说得很清楚：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-median-from-data-stream/solution/you-xian-dui-lie-python-dai-ma-java-dai-ma-by-liwe/">https://leetcode-cn.com/problems/find-median-from-data-stream/solution/you-xian-dui-lie-python-dai-ma-java-dai-ma-by-liwe/</a></p>
<p>思路就是观察到中位数实际上就是前后两个数组的最大值和最小值，这个时候就用堆来实现就好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    Queue&lt;Integer&gt; maxQueue;</span><br><span class="line">    Queue&lt;Integer&gt; minQueue;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        maxQueue=<span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> b-a;</span><br><span class="line">        &#125;);</span><br><span class="line">        minQueue=<span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        maxQueue.offer(num);</span><br><span class="line">        minQueue.offer(maxQueue.poll());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((count&amp;<span class="number">1</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">            maxQueue.offer(minQueue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((count&amp;<span class="number">1</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)maxQueue.peek();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (maxQueue.peek()+minQueue.peek())/(<span class="number">2.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>犯下的错误：</p>
<p>1.注意java中的数据类型转换，if语句中1不是boolean类型，需要自己做一个==的判断才可以。</p>
<p>2.返回答案的时候，注意返回double类型，自己要在前面做一个强制类型转换。</p>
<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h4><p>下面是liweiwei的答案，我写一下具体的思路。</p>
<p>大的思路是找分割线。这里找分割线的原则是在小数组里面找。这里以小数组的left和right作为边界，然后一直找到符合条件的边界。</p>
<p>这里有边界i和边界j。其中，边界i是由每次查找的区间取中间确定的，而边界j是由长度减去i所确定的。其中，区间变换的原则是用nums1[i-1]和nums2[j]比较，用nums[i]和nums2[j-1]比较。通过比较的不同情况，对边界进行调整。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割线左边的所有元素需要满足的个数 m + (n - m + 1) / 2;</span></span><br><span class="line">        <span class="keyword">int</span> totalLeft = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 nums1 的区间 [0, m] 里查找恰当的分割线，</span></span><br><span class="line">        <span class="comment">// 使得 nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = totalLeft - i;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间 [left, i - 1]</span></span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间 [i, right]</span></span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = totalLeft - i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nums1LeftMax = i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> nums1RightMin = i == m ? Integer.MAX_VALUE : nums1[i];</span><br><span class="line">        <span class="keyword">int</span> nums2LeftMax = j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> nums2RightMin = j == n ? Integer.MAX_VALUE : nums2[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((m + n) % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums1LeftMax, nums2LeftMax);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>) ((Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin))) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="63-不同路径-II-1"><a href="#63-不同路径-II-1" class="headerlink" title="63. 不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a></h4><p>思路。</p>
<p>首先写一下不考虑任何情况的递归的方程。</p>
<p>这里我们明显是设立一个二维数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]表示的是到矩阵i,j点的路径方式</span><br></pre></td></tr></table></figure>

<p>由于机器人只能向下或者向右移动，因此</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">想到i,j 只能是i-<span class="number">1</span>,j或者是i,j-<span class="number">1</span>出发开始移动。</span><br></pre></td></tr></table></figure>

<p>所以可以得到一个递推方程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>]</span><br><span class="line">另外需要考虑障碍物的情况，一旦</span><br><span class="line">    obstacleGrid[i][j]==<span class="number">0</span></span><br><span class="line">    那么显然dp[i][j]==<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>考虑数组的初始化，主要是对边界的初始化：</p>
<p>如果没有障碍物，那么上边界即i=0的点都是1，左边界即j=0的点也都是1。<strong>不过这里要注意，一旦出现了一个障碍物，那么接下来点也全部都是0。</strong></p>
<p>所以可以写出如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid==<span class="keyword">null</span>||obstacleGrid[<span class="number">0</span>].length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row=obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> col=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row&amp;&amp;obstacleGrid[i][<span class="number">0</span>]==<span class="number">0</span>;i++)&#123; <span class="comment">//在没有障碍物的情况下，对dp进行初始化</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col&amp;&amp;obstacleGrid[<span class="number">0</span>][j]==<span class="number">0</span>;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最为重要的记忆点其实就是对边界的初始化，应该算一道ease题目。</p>
<h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h4><p>这道题要审清楚题目。</p>
<p>这里说的是能否将字符串连续拆分成字典里的字符串。</p>
<p>这里一个思路是遍历字符串，然后对于一串序列看是否在字典里。</p>
<p>我们用两个指针，low和high来指定我们讨论的子串的上标和下标。其中一个思路是，我们从0出发，依次以字典里的单词的长度为顺序，查看low–low+dicString.length是与字典的子串相同。如果在一个点，都找不到相同的，那么就可以跳出循环结束；否则则继续直到字符串结束。</p>
<p>于是我们选择用一个数组来记录每一点的拆解情况，如果一个点可以被拆解，那么就记为true，否则为false。而只有当dp[n]=true的时候，才认为可以将单词成功拆分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[len+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> low=<span class="number">0</span>;low&lt;len;low++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[low]==<span class="keyword">false</span>)<span class="keyword">continue</span>; <span class="comment">//注意这个剪枝的边界，然后是注意dp数组的下标的+1关系</span></span><br><span class="line">            <span class="keyword">for</span>(String str:wordDict)&#123;</span><br><span class="line">                <span class="keyword">int</span> high=low+str.length();</span><br><span class="line">                <span class="keyword">if</span>(high&lt;=len&amp;&amp;s.substring(low,high).equals(str))&#123;</span><br><span class="line">                    dp[high]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个视频讲得很清楚其实：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=KppuKbiBX78&amp;ab_channel=happygirlzt">https://www.youtube.com/watch?v=KppuKbiBX78&amp;ab_channel=happygirlzt</a></p>
<h4 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/candy/">135. 分发糖果</a></h4><p>参考视频：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=sHnbaKcx-Kg&amp;ab_channel=M.C%E7%B1%B3%E5%BC%80%E6%9C%97%E5%9F%BA%E7%BD%97">https://www.youtube.com/watch?v=sHnbaKcx-Kg&amp;ab_channel=M.C%E7%B1%B3%E5%BC%80%E6%9C%97%E5%9F%BA%E7%BD%97</a></p>
<p>思路：就是左右两次遍历。</p>
<p>先是向左遍历，遇到上升沿就加1。</p>
<p>然后是向右遍历，同样是遇到上升沿就加1。</p>
<p>最后将两次遍历的最大值做一个汇总即可。取两次遍历的最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=ratings.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] left=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] right=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(left,<span class="number">1</span>);</span><br><span class="line">        Arrays.fill(right,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                left[i]=left[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=len-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[j]&lt;ratings[j-<span class="number">1</span>])&#123;</span><br><span class="line">                right[j-<span class="number">1</span>]=right[j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>  ret=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            ret+=Math.max(left[i],right[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h4><p>这道题其实是一道完全背包问题。不过用到了背包问题思想，完全不用全都靠背包的解法来做。而是自己想一想条件，就可以将dp方程写出来。</p>
<p>如果用递归来做这道题的话，希望组成的n相同的情况下，用到的数尽可能小。可以想到列举所有的情况。</p>
<p>用子问题的思路来求解这道题。</p>
<p>这里思考dp[n]和dp[n-x]的关系，假设这里x是平方数。可以写出</p>
<p>dp[n]=Math.min(dp[n],dp[n-x]+1);</p>
<p>这里注意初始化一下数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.形成完全平方数列表，列表对应i值。</span></span><br><span class="line"><span class="comment">        2.j是target值n。</span></span><br><span class="line"><span class="comment">        3.返回结果是min值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        当然，可以用经典完全背包思路做这道题，但是也可以用背包的改编来思考这道题。</span></span><br><span class="line"><span class="comment">        f[n]代表的是组成n的最小数量。所以f[n]和f[n-x]的关系，可能就是f[n]=f[n-x]。不过是f[n]一直在记录最小值而已。</span></span><br><span class="line"><span class="comment">        dp的核心其实是记忆。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(dp,Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=i*i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=x;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[j]=Math.min(dp[j],dp[j-x]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></h4><p>这道题求解的是可以凑成amount的组合的总数。说实话，刚开始拿到题目有一点儿懵。</p>
<p>这里考虑完全背包，即</p>
<p>对于第i个硬币，有两种情况</p>
<pre><code>  dp[i] [j]=dp[i-1] [j]</code></pre>
<p>还有一种情况我写的时候似乎遇到了困难：</p>
<p>​    我开始是这样写的：</p>
<p>​    dp[i] [j]=dp[i-1] [j-coins[i]]</p>
<p>但是这样写不太对，因为coins实际上可以选择多次，因此应该改写成：</p>
<p>​    dp[i] [j]=dp[i-1] [j-coins[i]]+dp[i-1] [j-coins[i]*2]+dp[i-1] [j-coins[i] *3] +。。。</p>
<p>但是这样写很冗余，因此做完全背包的二维优化：</p>
<p>​    dp[j]+=dp[j-coins[i]]</p>
<h4 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></h4><p>要求最长的递增路径。考虑到如果要考察路径的话，可能需要对表格中的每个节点做遍历。</p>
<p>遍历的过程可以用递归来考虑。比如说一个节点可以有上下左右四种行走的方向。那么其最长路径的值当然是是个方向的最大值。因此以改点为起点的最大长度即可以记录在一个数组中，同时该节点前方可能也有路径到达该点，其值返回加和即可。</p>
<p>1.建立dp表格。</p>
<p>2.对于每一个表格，为起点开始遍历。</p>
<p>3.如果这个表格之前已经遍历过了，有值了就不遍历。</p>
<p>遍历过程：</p>
<p>1.判断边界条件。如果到了边界就返回0。</p>
<p>2.如果一个节点有值了，那么就返回该节点的值。</p>
<p>3.否则就继续递归，然后返回递归的结果+1.</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> len2=matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[len1][len2];</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    dfs(matrix,i,j,dp,Integer.MIN_VALUE);<span class="comment">//这里传入的是MIN_VALUE</span></span><br><span class="line">                    res=Math.max(res,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] dp,<span class="keyword">int</span> prev)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=matrix.length||j&gt;=matrix[<span class="number">0</span>].length||i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||prev&gt;=matrix[i][j])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j]!=<span class="number">0</span>)<span class="keyword">return</span> dp[i][j];<span class="comment">//表格已经有值了也是一个重要返回条件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left=dfs(matrix,i,j-<span class="number">1</span>,dp,matrix[i][j]);</span><br><span class="line">        <span class="keyword">int</span> right=dfs(matrix,i,j+<span class="number">1</span>,dp,matrix[i][j]);</span><br><span class="line">        <span class="keyword">int</span> up=dfs(matrix,i+<span class="number">1</span>,j,dp,matrix[i][j]);</span><br><span class="line">        <span class="keyword">int</span> down=dfs(matrix,i-<span class="number">1</span>,j,dp,matrix[i][j]);</span><br><span class="line"></span><br><span class="line">        dp[i][j]=Math.max(left,Math.max(right,Math.max(up,down)))+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h4><p>0-1背包问题。见到这种题目，似乎就是套套公式就可以了~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        a+b=sum</span></span><br><span class="line"><span class="comment">        a-b=target</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        a=(sum+target)/2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i]]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        dp[j]=dp[j]+dp[j-nums[i]]</span></span><br><span class="line"><span class="comment">        dp[0][0]=1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(target&gt;sum||(sum-target)%<span class="number">2</span>==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//还是仔细想想count是怎么求解的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count=(sum-target)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=count;j&gt;=num;j--)&#123;</span><br><span class="line">                dp[j]=dp[j]+dp[j-num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[count];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1981-最小化目标值与所选元素的差"><a href="#1981-最小化目标值与所选元素的差" class="headerlink" title="1981. 最小化目标值与所选元素的差"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimize-the-difference-between-target-and-chosen-elements/">1981. 最小化目标值与所选元素的差</a></h4><p>这道题是周赛的题目，自己也是看了背包之后，似乎是可以将这道题写出来了，但是可能今天精神状态都不太好，这里写的边界有一些问题。</p>
<p>其实这里和之前的背包一点小不同，以前的背包的话，是第i个选不选，这里的话，是第i次选选哪一个。</p>
<p>背包的理解可以用写dfs的方式来列写。</p>
<p>如果要写一个dfs的话，首先肯定要记录dfs的层数，在这里就是搜索到哪列了，另外是dfs的终结条件，什么情况下得到想要的结果：即找到了最终数的加和，所以也要维持一个加和。</p>
<p>所以就有了dp数组最重要的两个元素，f[i] [j]  分别对应的是：</p>
<p>i:-第i行。</p>
<p>j:当前的加和。</p>
<p>这里改变的结果应当是 是否可以取到j。因此设定这是一个boolean数组。</p>
<p>这里一个问题是可能需要引入第3个变量x，代表当前选择的数。这是和传统背包不同的地方，所以转移方程可以写成：</p>
<p>f[i] [j]=f[i] [j]||f[i-1] [j-x]</p>
<p>这里注意如果已经可以取到true的情况，要保留这个true的情况。其实也可以做一个启发，如果f[i] [j]已经是真的了，就不需要再考虑了。</p>
<p>下面思考如何遍历以及初始条件。</p>
<p>初始条件就是对于第一列的元素，可以默认其对应的j都是true的。</p>
<p>就是f[0] [x]都是true.符合我们的dp数组的定义。</p>
<p>遍历的话，当然是从前往后遍历，背包问题的遍历也很套路，就是先遍历层数i,内部遍历j。</p>
<p>所以就可以写出下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimizeTheDifference</span><span class="params">(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        f[i][j]=f[i][j]||f[i-1][j-x]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> len1=mat.length;</span><br><span class="line">        <span class="keyword">int</span> len2=mat[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] f=<span class="keyword">new</span> <span class="keyword">boolean</span>[len1][<span class="number">4901</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:mat[<span class="number">0</span>])&#123;</span><br><span class="line">            f[<span class="number">0</span>][x]=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num:mat[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=num;j&lt;<span class="number">4901</span>;j++)&#123;</span><br><span class="line">                    f[i][j]=f[i][j]||f[i-<span class="number">1</span>][j-num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans1=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> ans2=Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=target;i&lt;<span class="number">4901</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[len1-<span class="number">1</span>][i]==<span class="keyword">true</span>)&#123;</span><br><span class="line">                ans1=i-target;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=target;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[len1-<span class="number">1</span>][i]==<span class="keyword">true</span>)&#123;</span><br><span class="line">                ans2=target-i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(ans1,ans2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步分析，这里数组开到了4901，但是target的量远小于4901。因此，可以考虑将数组开到target长度，然后对于大于target的值，直接记录即可。</p>
<h4 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uh411o7Si?from=search&amp;seid=8344112185875136350">https://www.bilibili.com/video/BV1uh411o7Si?from=search&amp;seid=8344112185875136350</a></p>
<h4 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h4><p>题意简单描述：</p>
<ul>
<li><code>&#39;.&#39;</code> 匹配任意单个字符</li>
<li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所以有一下的情况：</p>
<p>首先试图写几个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s=aaa</span><br><span class="line">p=aaa</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">s=aaa</span><br><span class="line">p=a*</span><br><span class="line">    </span><br><span class="line">s=b</span><br><span class="line">p=a*b</span><br></pre></td></tr></table></figure>



<p>1.首先判断首字符是否匹配。</p>
<p>2.然后判断第二个字符是否是*</p>
<p>​        如果是*，那么既可以是</p>
<p>​                                            isMatch(s,p.substring(2))//取*为0</p>
<p>​                                也可以是</p>
<p>​                                        firstMatch&amp;&amp;isMatch(s.sbstring(1),p)//取*为n</p>
<p>于是又下面的递归写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.length() == <span class="number">0</span>) <span class="keyword">return</span> s.length() == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> firstMatch = s.length() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (s.charAt(<span class="number">0</span>) == p.charAt(<span class="number">0</span>) || p.charAt(<span class="number">0</span>) == <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.length() &gt;= <span class="number">2</span> &amp;&amp; p.charAt(<span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s, p.substring(<span class="number">2</span>)) ||</span><br><span class="line">             (firstMatch &amp;&amp; isMatch(s.substring(<span class="number">1</span>), p));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> firstMatch &amp;&amp; isMatch(s.substring(<span class="number">1</span>), p.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键点：1.举出例子，先比较第一个字符。2.比较第二个字符，根据是否是*进一步判断。</p>
<p>dp的解法再看一下：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/solution/shua-chuan-lc-dong-tai-gui-hua-jie-fa-by-zn9w/">https://leetcode-cn.com/problems/regular-expression-matching/solution/shua-chuan-lc-dong-tai-gui-hua-jie-fa-by-zn9w/</a></p>
<h4 id="440-字典序的第K小数字"><a href="#440-字典序的第K小数字" class="headerlink" title="440. 字典序的第K小数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> cur = <span class="number">1</span>; <span class="comment">//初始节点指向1</span></span><br><span class="line">        k -= <span class="number">1</span>;<span class="comment">//第一个节点，那么就直接k--</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;<span class="comment">//每次遍历都会减去k，因此当k为0的时候，就完成了遍历</span></span><br><span class="line">            <span class="keyword">int</span> nodes = countNodes(n, cur);<span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt;= nodes) &#123;</span><br><span class="line">                cur += <span class="number">1</span>;<span class="comment">//如果k比当前节点下的节点多，那么cur就偏移一下</span></span><br><span class="line">                k -= nodes;<span class="comment">//k减去对应的节点数量</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur *= <span class="number">10</span>;<span class="comment">//否则，cur就进入下一层，进入下一层这个过程，相当于舍弃了一个节点</span></span><br><span class="line">                k--;<span class="comment">//因为舍弃了一个节点，相当于k--</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) cur;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> cur)</span> </span>&#123; <span class="comment">//这个代码好难想，要举例子才行</span></span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> next = cur + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt;= n) &#123;</span><br><span class="line">            total += Math.min(n - cur + <span class="number">1</span>, next - cur);</span><br><span class="line">            cur *= <span class="number">10</span>;</span><br><span class="line">            next *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自己的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> cur=<span class="number">1</span>; <span class="comment">//注意是long类型</span></span><br><span class="line">        k--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> nodes=countNoder(n,cur);</span><br><span class="line">            <span class="keyword">if</span>(k&lt;nodes)&#123;</span><br><span class="line">                cur=cur*<span class="number">10</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur=cur+<span class="number">1</span>;</span><br><span class="line">                k=k-nodes;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNoder</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">long</span> cur)</span></span>&#123;</span><br><span class="line">       <span class="keyword">long</span> total=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">long</span> next=cur+<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(cur&lt;=n)&#123;</span><br><span class="line">           total+=Math.min(n-cur+<span class="number">1</span>,next-cur);</span><br><span class="line">           cur=cur*<span class="number">10</span>;</span><br><span class="line">           next=next*<span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">int</span>)total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168. Excel表列名称"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/excel-sheet-column-title/">168. Excel表列名称</a></h4><p>一个思路题，只要记住这种思路；但是如果没有思路的话，想起来估计还挺麻烦的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(columnNumber!=<span class="number">0</span>)&#123;</span><br><span class="line">            columnNumber--;</span><br><span class="line">            sb.append((<span class="keyword">char</span>)(columnNumber%<span class="number">26</span>+<span class="string">&#x27;A&#x27;</span>));<span class="comment">//这里注意char要做一个转换</span></span><br><span class="line">            columnNumber=columnNumber/<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个例子：</p>
<p>总之要注意无论是取余的时候还是/的时候都要减去1。因此直接减减就好。</p>
<h4 id="GCD算法（辗转相除法）"><a href="#GCD算法（辗转相除法）" class="headerlink" title="GCD算法（辗转相除法）"></a>GCD算法（辗转相除法）</h4><p>记住下面这个图，记住跳楼梯的过程是取模即可：</p>
<p><img src="https://slowsail-gulifile.oss-cn-hangzhou.aliyuncs.com/img/image-20220907205711883.png" alt="image-20220907205711883"></p>
<h4 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/super-egg-drop/">887. 鸡蛋掉落</a></h4><p>假设鸡蛋数是K,所站立的楼层是N。</p>
<p>那么考虑状态之间的转移。</p>
<p>如果在楼层N下面的x扔了一个鸡蛋：</p>
<p>​    1.鸡蛋碎了：k=k-1,N=x-1</p>
<p>​    2.鸡蛋没有碎：k,N-X（注意，这里将楼层N理解为需要找寻临界点的楼层数 ）</p>
<p>所以可以写下面的转移方程：</p>
<p>f(K,N)=max(f(K-1,X-1),f(K,N-X))</p>
<p>这里的X通过遍历得到，注意，我们求的应该是遍历的最小值。</p>
<p>对于上面的函数，如果用递归的话，会计算许多中间节点，于是考虑用数组存储答案。</p>
<p>想用数组存储答案，首先确定一些特殊值：</p>
<p>这里思考下我们的程序如何设计：</p>
<p>1.首先是我们其实就是求一个dp[n] [k]的问题。</p>
<p>为了避免重复计算，我们使用一个map，利用map来将n*100+k作为key（这里是防止n+key和key之间相互冲突的一种方法），然后将对应的n,k情况的值存储在map中。</p>
<p>2.对于每个n,k。首先看之前是否求解过，如果没有求解过，那么首先我们知道 dp[k] [n]=Math.min(Math.max(dp[k-1] [x],dp[k] [n-x]]))</p>
<p>这里我们就要想办法去求dp[k-1] [x]和dp[k] [n-x]两者最大值的最小值。</p>
<p>然后由于上面两个值和x的关系是：</p>
<p><img src="https://gitee.com/SlowSail/blogIMg/raw/master//img/image-20210826140838217.png" alt="image-20210826140838217"></p>
<p>故我们的目标就是求出x0和x1,然后取其中（两者最大值）的最小值。</p>
<p>又我们x的范围是0-n。<strong>且记住（数学证明）x1-x0=1</strong></p>
<p>所以我们可以用二分查找来确定x1和x0。</p>
<p>二分查找的终止条件是 left+1=right这个时候就认为找到了。</p>
<p>如果说dp[k-1] [x]=t1,dp[k] [n-x]=t2</p>
<p>如果t1&gt;t2  那么说明x大了,right=mid;</p>
<p>如果t1&lt;t2 说明x小了，left=mid;</p>
<p>依照这种思路即可求解题目。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp(k,n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(<span class="number">100</span>*n+k))<span class="keyword">return</span> map.get(<span class="number">100</span>*n+k);</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> high=n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low+<span class="number">1</span>&lt;high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(high+low)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> t1=dp(k-<span class="number">1</span>,mid-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> t2=dp(k,n-mid);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(t1&gt;t2)&#123;</span><br><span class="line">                high=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans=Math.min(Math.max(dp(k-<span class="number">1</span>,low-<span class="number">1</span>),dp(k,n-low)),Math.max(dp(k-<span class="number">1</span>,high-<span class="number">1</span>),dp(k,n-high)))+<span class="number">1</span>; <span class="comment">//状态转移方程要想清楚，不然会做的题会做错</span></span><br><span class="line">        map.put(n*<span class="number">100</span>+k,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要把上面的题目当成多难的题目。其实就是求出了一个稍微复杂的dp数组，然后改数组需要用二分法确定一下范围，仅此而已。</p>
<h4 id="400-第-N-位数字"><a href="#400-第-N-位数字" class="headerlink" title="400. 第 N 位数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nth-digit/">400. 第 N 位数字</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>  digit=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> start=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> countIndex=digit*<span class="number">9</span>*start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n&gt;countIndex)&#123;</span><br><span class="line">            n=n-(<span class="keyword">int</span>)countIndex;</span><br><span class="line">            start=start*<span class="number">10</span>;</span><br><span class="line">            digit=digit+<span class="number">1</span>;</span><br><span class="line">            countIndex=digit*<span class="number">9</span>*start;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> num=start+(n-<span class="number">1</span>)/digit;</span><br><span class="line">        <span class="keyword">int</span> bitSet=(n-<span class="number">1</span>)%digit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)((String.valueOf(num).charAt(bitSet))-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此题最后要注意一下输入的值可能不讲武德，虽然输入在int类型内，可是可能会导致start和countIndex超出范围。</p>
<p>然后就是一个找规律题。</p>
<p>这里最后的n-1是一个巧妙的思路。</p>
<h4 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h4><p>自己的解法，总是不知道哪里有错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        count=k;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        search(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        search(root.left);</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(--count==<span class="number">0</span>)ans=root.val;</span><br><span class="line">        search(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后发现是right和left写反了。</p>
<p>这个写反不仅仅是不小心，更是没有搞清楚题意。题目说的是第K大的，这就要求要降序排列。因此是中序排列的倒序。即先遍历right再遍历left。</p>
<h4 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">二叉搜索树与双向链表</a></h4><p>思路是中序遍历然后建立双链表。</p>
<p>这里一个点就是需要维护一个head和pre。</p>
<p>在遍历一个点的时候的行为是：</p>
<p>1.pre.right=root;</p>
<p>root.left=pre;</p>
<p>pre=root;</p>
<p>用图画一下理解一下。</p>
<p>对于head为空的情况，证明之前没有pre，所以这个时候要head==null。</p>
<p>觉得是一道记忆题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node pre=<span class="keyword">null</span>;</span><br><span class="line">    Node head=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1.边界条件，如果是root那么就返回。</span></span><br><span class="line"><span class="comment">            2.对root做dfs操作。</span></span><br><span class="line"><span class="comment">            3.对首部和尾部的节点做操作处理</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> root;</span><br><span class="line">        dfs(root);</span><br><span class="line">        head.left=pre;</span><br><span class="line">        pre.right=head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)head=root;</span><br><span class="line">        <span class="keyword">else</span> pre.right=root;</span><br><span class="line">        root.left=pre;</span><br><span class="line">        pre=root;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h4><p>这道题一个直观的思路是利用中序遍历，记录一下上次遍历的点，然后比较当前节点和上次遍历节点的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        pre=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> left=dfs(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="keyword">null</span>&amp;&amp;pre.val&gt;=root.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        pre=root;</span><br><span class="line">        <span class="keyword">boolean</span> right=dfs(root.right);</span><br><span class="line">        <span class="keyword">return</span> right&amp;&amp;left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实和转成双链表挺像的，可以联系起来复习。</p>
<h4 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/interleaving-string/">97. 交错字符串</a></h4><p>建议自己用一个例子过一遍，这道题就是靠记忆，我觉得没法想出来。</p>
<p>其实就还是像用双指针一样做对比，不过用了一个dp数组来做记录。</p>
<p>其中，初始化dp数组为真，然后后面就是判断s1和s2对应的字符是否能与s3契合。</p>
<p>官方题解讲得还行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1=s1.length();</span><br><span class="line">        <span class="keyword">int</span> len2=s2.length();</span><br><span class="line">        <span class="keyword">int</span> len3=s3.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len1+len2!=len3)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=len2;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> p=i+j-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)dp[i][j]=dp[i][j]||(dp[i-<span class="number">1</span>][j]&amp;&amp;s1.charAt(i-<span class="number">1</span>)==s3.charAt(p));</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)dp[i][j]=dp[i][j]||(dp[i][j-<span class="number">1</span>]&amp;&amp;s2.charAt(j-<span class="number">1</span>)==s3.charAt(p));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最好理解一下dp数组的下标含义。其中，dp[0] [0]意义是s1和s2都为空的时候，因此此时为真。</p>
<p><strong>而dp[1] [1]意义是s1和s2中的第一个元素是否可以交错组合成s3的前两个元素</strong>。因此dp[1] [1]比较的自然是s.charAt(i-1)即下标里面的0元素。</p>
<p>另外考虑一下如何优化这个数组。</p>
<p>优化数组的事情最好绘制一个图来实现</p>
<p>不过我看了一下图，觉得这道题其实不是很好用滚动数组来解释。因为这里其实相当于以s2为基准，dp通过的要求是做两次检验，有一次可以通过即可以接受，然后优化为一个维度的数组作这件事情即可。</p>
<h4 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h4><p>说实话，人傻了，一个低级错误卡了半天。</p>
<p><strong>因此，要养成做完题过一遍代码的习惯。能省时间而不是费时间。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        dfs(root,target,res,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> target,List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span>(root!=<span class="keyword">null</span>&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123; <span class="comment">//这个低级错误是把树的轴给写错了</span></span><br><span class="line">          <span class="keyword">if</span>(target-root.val==<span class="number">0</span>)&#123;</span><br><span class="line">              list.add(root.val);</span><br><span class="line">              res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">              list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      list.add(root.val);</span><br><span class="line">      dfs(root.left,target-root.val,res,list);</span><br><span class="line">      dfs(root.right,target-root.val,res,list);</span><br><span class="line">      list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h4><p>发现自己的编码习惯是真的差劲。</p>
<p>在变量改变的时候，用if 语句，结果下面没写else，然后就继续执行if语句了。。。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.排序</span></span><br><span class="line"><span class="comment">        2.确定第一个数</span></span><br><span class="line"><span class="comment">        3.确定第二个数。尤其记忆的是为了防止重复而做的判断。</span></span><br><span class="line"><span class="comment">        4.双指针靠拢。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">4</span>)<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])&#123; <span class="comment">//这个要记忆啊</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>]&gt;target)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[len-<span class="number">1</span>]+nums[len-<span class="number">2</span>]+nums[len-<span class="number">3</span>]&lt;target)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len-<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[j+<span class="number">1</span>]+nums[j+<span class="number">2</span>]&gt;target)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]+nums[len-<span class="number">1</span>]+nums[len-<span class="number">2</span>]&lt;target)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> left=j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right=len-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(left&gt;j+<span class="number">1</span>&amp;&amp;left&lt;right&amp;&amp;nums[left]==nums[left-<span class="number">1</span>])left++;</span><br><span class="line">                    <span class="keyword">while</span>(right&lt;len-<span class="number">1</span>&amp;&amp;right&gt;len&amp;&amp;nums[right]==nums[right+<span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">if</span>(left&gt;=right)<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]+nums[j]+nums[left]+nums[right]==target)&#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[j]+nums[left]+nums[right]&lt;target) left++;</span><br><span class="line">                    <span class="keyword">else</span> right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指 Offer 62. 圆圈中最后剩下的数字</a></h4><p>约瑟夫环问题。</p>
<p>记忆的题目。关键是理解倒推的思路。</p>
<p>比如说下面的例子：</p>
<p>0 1 2 3 4</p>
<p>3 4 0 1</p>
<p>1 3 4</p>
<p>1 3</p>
<p>3</p>
<p>每次删除第3个。</p>
<p>我们可以确定，最后我们求的那个数的下标是0。那么我们就可以推出该数在上一轮的下标。</p>
<p>求法是（cur+m)%arrayNum</p>
<p>即是（前一轮的下标+偏移的位置）%数组上一轮的长度。</p>
<p>因此，数组的长度是从2到n。</p>
<p>前一轮的下标从0开始更新。</p>
<p>所以可以写出下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            ans=(ans+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a></h4><p>看这个视频题解即可：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ZV0InYdJKYw&amp;t=185s&amp;ab_channel=happygirlzt">https://www.youtube.com/watch?v=ZV0InYdJKYw&amp;t=185s&amp;ab_channel=happygirlzt</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.大循环遍历每一个点，如果是空，那么就进行判断。</span></span><br><span class="line"><span class="comment">        2如果说大循环可以顺利结束，那么就返回。</span></span><br><span class="line"><span class="comment">        3.中间需要判断是否可以填入点，判断方式包括：</span></span><br><span class="line"><span class="comment">            1.行</span></span><br><span class="line"><span class="comment">            2.列</span></span><br><span class="line"><span class="comment">            3.3*3矩阵：</span></span><br><span class="line"><span class="comment">                确定矩阵所在的行：3*(row/3)+i/3</span></span><br><span class="line"><span class="comment">                确定矩阵所在的列：3*(col/3)+i/3</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        helper(board);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">char</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][i]==k)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col]==k)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">3</span>*(row/<span class="number">3</span>)+i/<span class="number">3</span>][<span class="number">3</span>*(col/<span class="number">3</span>)+i%<span class="number">3</span>]==k)<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//这是找同一个矩阵的相同的值的一个trick</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> k=<span class="string">&#x27;1&#x27;</span>;k&lt;=<span class="string">&#x27;9&#x27;</span>;k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(isValid(board,i,j,k))&#123;</span><br><span class="line">                            board[i][j]=k;</span><br><span class="line">                            <span class="keyword">if</span>(helper(board))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                            board[i][j]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.维护一个栈，存储下标。</span></span><br><span class="line"><span class="comment">        2.其中，入栈和出栈的原则是：</span></span><br><span class="line"><span class="comment">            如果遇到一个比栈顶大的数：入栈</span></span><br><span class="line"><span class="comment">            如果遇到一个比栈顶小的数：将栈里的数先出栈，计算之前的栈内元素所可以组成的矩形的大小</span></span><br><span class="line"><span class="comment">            更新维护最大值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Deque&lt;Integer&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len=heights.length;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(stack.peek()!=-<span class="number">1</span>&amp;&amp;heights[i]&lt;=heights[stack.peek()])&#123;</span><br><span class="line">                max=Math.max(max,heights[stack.pop()]*(i-stack.peek()-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;<span class="comment">//这个时候栈内的元素都是单调递增的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(stack.peek()!=-<span class="number">1</span>)&#123;</span><br><span class="line">            max=Math.max(max,heights[stack.pop()]*(len-stack.peek()-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题最为重要的思想就是边界的确定。如果维持栈内的数据是单调增加的话，那么最终计算的时候，相当于右边的边界就是n，而左边的边界就是栈内的元素。在入栈过程中，遇到较小值出栈的时候，相当于是找到了左边界，而由于前面的数比当前数小，因此右边界也是确定，因此可以用上述写法。</p>
<h4 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547. 省份数量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></h4><p>虽然深度优先直接想出来了，但是还是看了下思路找想到用深度优先。</p>
<p>联通图有机会可以想一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.深度优先的思路其实就还比较平和。</span></span><br><span class="line"><span class="comment">        2.就是维护一个访问数组，如果有一个节点在大循环里没有被访问过，那么计数器就++</span></span><br><span class="line"><span class="comment">        3.然后对于一个新的节点，利用dfs，将其周围的点全部都访问。这样计数器只有在新连通图的时候才++</span></span><br><span class="line"><span class="comment">        然后注意 isConnected[i][j] 表示第i个点和第j个点相连</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> len=isConnected.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                dfs(i,isConnected,visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span>[][] isConnected,<span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i])<span class="keyword">return</span>;</span><br><span class="line">        visited[i]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;isConnected.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isConnected[i][j]==<span class="number">1</span>&amp;&amp;!visited[j])&#123;</span><br><span class="line">                dfs(j,isConnected,visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和</a></h4><p>显然自己把三数之和给忘记了~~~</p>
<p>有些操作就不对，有时间复习一下三数之和（其实昨天刚写了四数之和）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//思路和三数之和一样应该</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">100000</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;<span class="number">0</span>&amp;&amp;i&lt;len-<span class="number">2</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])i++;</span><br><span class="line">            <span class="keyword">int</span> left=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right=len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> num=nums[i]+nums[left]+nums[right];</span><br><span class="line">                <span class="keyword">if</span>(num==target)<span class="keyword">return</span> target;</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(num-target)&lt;Math.abs(ans-target))ans=num;</span><br><span class="line">                <span class="keyword">if</span>(num&gt;target)right--;</span><br><span class="line">                <span class="keyword">else</span> left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//if(ans&gt;target)return ans;这个减枝操作是错误的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h4><p>这道题还是要画图自己看着理解一下。</p>
<p>本质是利用画图之后节点之间的关系来解题。</p>
<p>思路如下：</p>
<p>1.给定数组的首部和尾部。</p>
<p>2.遍历寻找第一个大于尾部的数（就是找左右子树的分界点）</p>
<p>3.找到分界点后，遍历后半部分（即右子树），看是否有小于尾部节点的点（不能小，小就错了）</p>
<p>4.递归搜索。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recurn(postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recurn</span><span class="params">(<span class="keyword">int</span>[] postorder,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin&gt;=end)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i=begin;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(postorder[i]&lt;postorder[end])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[i]&gt;postorder[end])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  i==end&amp;&amp;recurn(postorder,begin,mid-<span class="number">1</span>)&amp;&amp;recurn(postorder,mid,end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h4><p>首先是一个左右两边遍历的思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> star=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;(&#x27;</span>)left++;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;)&#x27;</span>)right++;</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">&#x27;*&#x27;</span>)star++;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;star+left)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right+star)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        left=<span class="number">0</span>;</span><br><span class="line">        right=<span class="number">0</span>;</span><br><span class="line">        star=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;)&#x27;</span>)right++;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;(&#x27;</span>)left++;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;*&#x27;</span>)star++;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right+star)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&gt;left+star)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个比较巧妙的思路：</p>
<p>维持一个low和一个high，这个low和high维持的是（括号的平衡性，比如出现了一个（，那么low和high都++。</p>
<p>如果不是左括号，那么low–。对于high来说，则判断是否是右括号，如果是右括号，那么减去1，否则加上1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValidString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> lo = <span class="number">0</span>, hi = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">char</span> c: s.toCharArray()) &#123;</span><br><span class="line">           lo += c == <span class="string">&#x27;(&#x27;</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">           hi += c != <span class="string">&#x27;)&#x27;</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (hi &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">           lo = Math.max(lo, <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> lo == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parenthesis-string/solution/">https://leetcode.com/problems/valid-parenthesis-string/solution/</a></p>
<h4 id="528-按权重随机选择-1"><a href="#528-按权重随机选择-1" class="headerlink" title="528. 按权重随机选择"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/random-pick-with-weight/">528. 按权重随机选择</a></h4><p>思路很清晰的题目。把代码看一下就行。</p>
<p>先求出前缀和，然后随机出一个数出来。</p>
<p>这里是 int targ = rand.nextInt(tot); 这样一个生成的下标的范围。</p>
<p>我写的不知道哪里错了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Random rand=<span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] w)</span> </span>&#123;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:w)&#123;</span><br><span class="line">            tot+=num;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> target=rand.nextInt(tot);</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high=list.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low!=high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(high+low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;=list.get(mid))low=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> high=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="525-连续数组"><a href="#525-连续数组" class="headerlink" title="525. 连续数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contiguous-array/">525. 连续数组</a></h4><p>这道题也是一个思路题。</p>
<p>具体的思路是：</p>
<p>由于nums里面只有0和1，想要0和1达到平衡，那么就计算数组的前缀和就好了。</p>
<p>比如0 1 0 1 0 0 0 1</p>
<p>前缀和就是：</p>
<p>-1 0 -1 0 -1 -2 -3 -2</p>
<p>那么就知道了 前缀和相同的下标间的数组肯定是平衡的（相当于+1和-1的数量是相同的）</p>
<p>但是有了这个思路之后还是要考虑要范围的问题（利用前缀和求解的时候都要想一想前缀和如何初始化的问题）</p>
<p>这里如果是0 1 0 1</p>
<p>那么前缀和是</p>
<p>-1 0 -1 0 那么显然有问题。因为最后一个前缀和显示不出效果。</p>
<p>所以前缀和可以多设置一个。初始前缀和为0.</p>
<p>用下面例子检验一下：</p>
<p>0 0 0 1 0 1 0 1 0 1 0 1 0</p>
<p>-1 -2 -3 -2 -3 -2 -3 -2 -3 -2 -3</p>
<p>所以前缀和要多一个。然后用map查找前缀和相同的下标的值的差距即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span>[] count=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;count.length;i++)&#123;</span><br><span class="line">            count[i]=count[i-<span class="number">1</span>]+(nums[i-<span class="number">1</span>]==<span class="number">0</span>?-<span class="number">1</span>:<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(count[i]))map.put(count[i],i);</span><br><span class="line">            <span class="keyword">else</span> ans=Math.max(ans,i-map.get(count[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多试几个例子，然后总结下规律就可以了。</p>
<p>leetcode50的视频题解：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=DKt7DAgJjbk&amp;ab_channel=happygirlzt">https://www.youtube.com/watch?v=DKt7DAgJjbk&amp;ab_channel=happygirlzt</a></p>
<h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h4><p>这道题有几个点。</p>
<p>首先是如何求单独一列的储水量。这个可以看题解：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">https://leetcode-cn.com/problems/trapping-rain-water/</a></p>
<p>其实就是想象一下，对于单独一列，<strong>其存水量就是两边最高的两个柱体中最矮的那一边减去当前的。</strong></p>
<p>有了这个思路之后，就是一个双指针的问题。</p>
<p>首先是一个计算列存水量的指针。根据题意，这个指针的范围当然是1—-length-2.</p>
<p>然后另外有一个存储maxLeft和maxRight的数。这两个数在不同的情况下进行更新。</p>
<p>然后如何保证每次都可以选择maxLeft和maxRight中较小的数进行计算呢？</p>
<p>这里通过控制每次指针所指向的旁边最近的高度值来实现，只要控制住在旁边最近的值中，每次更新小的那边就可以了。</p>
<p>核心代码逻辑如下</p>
<figure class="highlight plain"><figcaption><span>(int i </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;从左到右更</span><br><span class="line">    if (height[left - 1] &lt; height[right + 1]) &#123;&#x2F;&#x2F;这里就是每次都选择小的一边更新</span><br><span class="line">        max_left &#x3D; Math.max(max_left, height[left - 1]);</span><br><span class="line">        int min &#x3D; max_left;</span><br><span class="line">        if (min &gt; height[left]) &#123;</span><br><span class="line">            sum &#x3D; sum + (min - height[left]);</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#x2F;&#x2F;从右到左更</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        max_right &#x3D; Math.max(max_right, height[right + 1]);</span><br><span class="line">        int min &#x3D; max_right;</span><br><span class="line">        if (min &gt; height[right]) &#123;</span><br><span class="line">            sum &#x3D; sum + (min - height[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h4><p>最基本的一个思路：</p>
<p>1.动态规划。直接看代码就行。就是说对于每一个nums[i]，都可以比较i前面的哪一个元素比当前元素小，然后将当前元素接在对应的元素前面，然后进行更新。注意一下的是循环过程。核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxans = Math.max(maxans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这道题另外有一个思路，是更新tail值的思路。</p>
<p><img src="https://slowsail-gulifile.oss-cn-hangzhou.aliyuncs.com/img/image-20220907205618268.png" alt="image-20220907205618268"></p>
<p>维护一个tail的数组，保证tail是递增的，如果新出现的数比tail小，那么就替换掉tail中最后一个比这个数大的数。</p>
<p>这样做的目的其实是因为长度其实都已经记录在res里面了，上图的情况中，如果下一个数是1，那么tail应该更新成为：</p>
<p>1    3     7</p>
<p>如果后面出现的数比7大，那么就相当于1没有替换。</p>
<p>如果后面出现的数比7小，那么其实就是替换前面的3，长度也没有增长。这个思路自己调试一下就可以跑通。</p>
<p>然后题目中为了优化，做了一个二分查找。这里找的逻辑是：</p>
<p>1.如果nums[mid]&lt;num,那么left=mid+1</p>
<p>2.如果&gt;=num,那么right=mid</p>
<p>同时注意什么时候更新长度：在最后取到右边界的时候更新长度。</p>
<h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h4><p>背包问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">参考代码：</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.如果可以分割，那么一定存在着dp[i]</span></span><br><span class="line"><span class="comment">        2.选择一定数，然后成为一个target这件事情，也可以分解成这个问题的子问题：</span></span><br><span class="line"><span class="comment">            dp[i][j]= dp[i-1][j]||dp[i-1][j-nums[i]];</span></span><br><span class="line"><span class="comment">        3.如果是背包的话，那么：</span></span><br><span class="line"><span class="comment">            在第i个选择，且容量为j的情况下，也可以分解为这个问题的子问题：</span></span><br><span class="line"><span class="comment">            dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-nums[i]])</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((sum&amp;<span class="number">1</span>)==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target=sum/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp[j]=dp[j]||dp[j-nums[i]]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;target+<span class="number">1</span>&amp;&amp;j&gt;nums[i];j++)&#123;</span><br><span class="line">                dp[j]=dp[j]||dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left+<span class="number">1</span>&lt;right&amp;&amp;nums[left+<span class="number">1</span>]==nums[left])&#123;</span><br><span class="line">                           left++;</span><br><span class="line">                           count++;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">while</span>(left&lt;(right-<span class="number">1</span>)&amp;&amp;nums[right-<span class="number">1</span>]==nums[right])&#123;</span><br><span class="line">                           right--;</span><br><span class="line">                           count++;</span><br><span class="line">                       &#125;</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">slowsail</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://slowsail.top/2021/09/22/leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/">https://slowsail.top/2021/09/22/leetcode%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://slowsail.top" target="_blank">slowsail'space</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%A2%98%E8%A7%A3/">题解</a></div><div class="post_share"><div class="social-share" data-image="/img/6.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/10/06/%E5%9C%A8%E7%BA%BF%E8%BF%90%E8%A1%8Cjava%E7%A8%8B%E5%BA%8F%E7%BD%91%E7%AB%99%E7%9A%84%E8%AE%BE%E8%AE%A1/"><img class="prev-cover" src="/img/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">在线运行java程序网站的设计</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/21/JUC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="/img/5.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC学习笔记-volatile的基本使用</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">slowsail</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/SlowSailKnowNothing" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1067235713@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%8F%E6%AC%A1%E5%81%9A%E9%A2%98%E9%9C%80%E8%A6%81%E6%A3%80%E6%9F%A5%E4%B8%80%E4%B8%8B%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">每次做题需要检查一下的问题：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">N皇后问题详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">子集问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">组合总和问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80"><span class="toc-number">5.</span> <span class="toc-text">复原IP地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="toc-number">6.</span> <span class="toc-text">22. 括号生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">7.</span> <span class="toc-text">150. 逆波兰表达式求值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">8.</span> <span class="toc-text">198. 打家劫舍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">9.</span> <span class="toc-text">124. 二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-number">10.</span> <span class="toc-text">49. 字母异位词分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">11.</span> <span class="toc-text">718. 最长重复子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">12.</span> <span class="toc-text">76. 最小覆盖子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-number">13.</span> <span class="toc-text">160. 相交链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">14.</span> <span class="toc-text">19. 删除链表的倒数第 N 个结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#478-%E5%9C%A8%E5%9C%86%E5%86%85%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%82%B9"><span class="toc-number">15.</span> <span class="toc-text">478. 在圆内随机生成点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">16.</span> <span class="toc-text">136. 只出现一次的数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-number">17.</span> <span class="toc-text">739. 每日温度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-53-I-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-I"><span class="toc-number">18.</span> <span class="toc-text">剑指 Offer 53 - I. 在排序数组中查找数字 I</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">19.</span> <span class="toc-text">410. 分割数组的最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#528-%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9"><span class="toc-number">20.</span> <span class="toc-text">528. 按权重随机选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4"><span class="toc-number">21.</span> <span class="toc-text">29. 两数相除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">22.</span> <span class="toc-text">25. K 个一组翻转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">23.</span> <span class="toc-text">232. 用栈实现队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="toc-number">24.</span> <span class="toc-text">92. 反转链表 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">25.</span> <span class="toc-text">23. 合并K个升序链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="toc-number">26.</span> <span class="toc-text">143. 重排链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="toc-number">27.</span> <span class="toc-text">155. 最小栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">28.</span> <span class="toc-text">234. 回文链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">29.</span> <span class="toc-text">165. 比较版本号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#468-%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80"><span class="toc-number">30.</span> <span class="toc-text">468. 验证IP地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="toc-number">31.</span> <span class="toc-text">221. 最大正方形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">32.</span> <span class="toc-text">128. 最长连续序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">33.</span> <span class="toc-text">15. 三数之和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#460-LFU-%E7%BC%93%E5%AD%98"><span class="toc-number"></span> <span class="toc-text">460. LFU 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98"><span class="toc-number">1.</span> <span class="toc-text">43. 字符串相乘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86"><span class="toc-number">2.</span> <span class="toc-text">498. 对角线遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">322. 零钱兑换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">394. 字符串解码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">5.</span> <span class="toc-text">152. 乘积最大子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">剑指 Offer 10- II. 青蛙跳台阶问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">191. 位1的个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">8.</span> <span class="toc-text">125. 验证回文串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#224-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">224. 基本计算器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81-1"><span class="toc-number">10.</span> <span class="toc-text">394. 字符串解码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">11.</span> <span class="toc-text">560. 和为K的子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#402-%E7%A7%BB%E6%8E%89-K-%E4%BD%8D%E6%95%B0%E5%AD%97"><span class="toc-number">12.</span> <span class="toc-text">402. 移掉 K 位数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#442-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">13.</span> <span class="toc-text">442. 数组中重复的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="toc-number">14.</span> <span class="toc-text">剑指 Offer 52. 两个链表的第一个公共节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#556-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-III"><span class="toc-number">15.</span> <span class="toc-text">556. 下一个更大元素 III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-number">16.</span> <span class="toc-text">剑指 Offer 51. 数组中的逆序对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81-2"><span class="toc-number">17.</span> <span class="toc-text">394. 字符串解码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">18.</span> <span class="toc-text">225. 用队列实现栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#443-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">19.</span> <span class="toc-text">443. 压缩字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="toc-number">20.</span> <span class="toc-text">75. 颜色分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">21.</span> <span class="toc-text">912. 排序数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">剑指 Offer 45. 把数组排成最小的数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#93-%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80"><span class="toc-number">23.</span> <span class="toc-text">93. 复原 IP 地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#662-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6"><span class="toc-number">24.</span> <span class="toc-text">662. 二叉树最大宽度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="toc-number">25.</span> <span class="toc-text">剑指 Offer 40. 最小的k个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">26.</span> <span class="toc-text">215. 数组中的第K个最大元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="toc-number">27.</span> <span class="toc-text">91. 解码方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">28.</span> <span class="toc-text">297. 二叉树的序列化与反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">29.</span> <span class="toc-text">459. 重复的子字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">30.</span> <span class="toc-text">55. 跳跃游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-II"><span class="toc-number">31.</span> <span class="toc-text">445. 两数相加 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II"><span class="toc-number">32.</span> <span class="toc-text">63. 不同路径 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#405-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0"><span class="toc-number">33.</span> <span class="toc-text">405. 数字转换为十六进制数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#384-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84"><span class="toc-number">34.</span> <span class="toc-text">384. 打乱数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#https-www-zhihu-com-search-q-E6-B4-97-E7-89-8C-E7-AE-97-E6-B3-95-amp-type-content"><span class="toc-number">35.</span> <span class="toc-text">https:&#x2F;&#x2F;www.zhihu.com&#x2F;search?q&#x3D;%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95&amp;type&#x3D;content</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8"><span class="toc-number">36.</span> <span class="toc-text">207. 课程表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="toc-number">37.</span> <span class="toc-text">剑指 Offer 61. 扑克牌中的顺子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">38.</span> <span class="toc-text">295. 数据流的中位数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">39.</span> <span class="toc-text">4. 寻找两个正序数组的中位数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II-1"><span class="toc-number">40.</span> <span class="toc-text">63. 不同路径 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">41.</span> <span class="toc-text">139. 单词拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number">42.</span> <span class="toc-text">135. 分发糖果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">43.</span> <span class="toc-text">279. 完全平方数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II"><span class="toc-number">44.</span> <span class="toc-text">518. 零钱兑换 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#329-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="toc-number">45.</span> <span class="toc-text">329. 矩阵中的最长递增路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">46.</span> <span class="toc-text">494. 目标和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1981-%E6%9C%80%E5%B0%8F%E5%8C%96%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%8E%E6%89%80%E9%80%89%E5%85%83%E7%B4%A0%E7%9A%84%E5%B7%AE"><span class="toc-number">47.</span> <span class="toc-text">1981. 最小化目标值与所选元素的差</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">48.</span> <span class="toc-text">208. 实现 Trie (前缀树)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">49.</span> <span class="toc-text">10. 正则表达式匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#440-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-number">50.</span> <span class="toc-text">440. 字典序的第K小数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#168-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0"><span class="toc-number">51.</span> <span class="toc-text">168. Excel表列名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GCD%E7%AE%97%E6%B3%95%EF%BC%88%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%EF%BC%89"><span class="toc-number">52.</span> <span class="toc-text">GCD算法（辗转相除法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD"><span class="toc-number">53.</span> <span class="toc-text">887. 鸡蛋掉落</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#400-%E7%AC%AC-N-%E4%BD%8D%E6%95%B0%E5%AD%97"><span class="toc-number">54.</span> <span class="toc-text">400. 第 N 位数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="toc-number">55.</span> <span class="toc-text">剑指 Offer 54. 二叉搜索树的第k大节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">56.</span> <span class="toc-text">二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">57.</span> <span class="toc-text">98. 验证二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#97-%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">58.</span> <span class="toc-text">97. 交错字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">59.</span> <span class="toc-text">剑指 Offer 34. 二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">60.</span> <span class="toc-text">18. 四数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">61.</span> <span class="toc-text">剑指 Offer 62. 圆圈中最后剩下的数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37-%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="toc-number">62.</span> <span class="toc-text">37. 解数独</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2"><span class="toc-number">63.</span> <span class="toc-text">84. 柱状图中最大的矩形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F"><span class="toc-number">64.</span> <span class="toc-text">547. 省份数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">65.</span> <span class="toc-text">16. 最接近的三数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-number">66.</span> <span class="toc-text">剑指 Offer 33. 二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#678-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">67.</span> <span class="toc-text">678. 有效的括号字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#528-%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9-1"><span class="toc-number">68.</span> <span class="toc-text">528. 按权重随机选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#525-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84"><span class="toc-number">69.</span> <span class="toc-text">525. 连续数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">70.</span> <span class="toc-text">42. 接雨水</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">71.</span> <span class="toc-text">300. 最长递增子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">72.</span> <span class="toc-text">416. 分割等和子集</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/26/shiro%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="shiro快速入门"><img src="https://gitee.com/SlowSail/blogIMg/blob/master/img/4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shiro快速入门"/></a><div class="content"><a class="title" href="/2021/12/26/shiro%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="shiro快速入门">shiro快速入门</a><time datetime="2021-12-26T07:18:16.000Z" title="发表于 2021-12-26 15:18:16">2021-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/18/JVM%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%88%9D%E6%8E%A2-jhat%EF%BC%8Cjps%EF%BC%8Cjstack/" title="JVM调试工具初探(jhat，jps，jstack)"><img src="/img/22.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM调试工具初探(jhat，jps，jstack)"/></a><div class="content"><a class="title" href="/2021/11/18/JVM%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%88%9D%E6%8E%A2-jhat%EF%BC%8Cjps%EF%BC%8Cjstack/" title="JVM调试工具初探(jhat，jps，jstack)">JVM调试工具初探(jhat，jps，jstack)</a><time datetime="2021-11-18T13:55:45.000Z" title="发表于 2021-11-18 21:55:45">2021-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/13/simpleDb%E5%AE%9E%E9%AA%8C%E4%B8%80%E8%AE%B0%E5%BD%95/" title="simpleDb实验一记录"><img src="/img/3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="simpleDb实验一记录"/></a><div class="content"><a class="title" href="/2021/11/13/simpleDb%E5%AE%9E%E9%AA%8C%E4%B8%80%E8%AE%B0%E5%BD%95/" title="simpleDb实验一记录">simpleDb实验一记录</a><time datetime="2021-11-13T12:25:29.000Z" title="发表于 2021-11-13 20:25:29">2021-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/13/%E6%BC%AB%E8%B0%88jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="漫谈jvm垃圾回收机制及垃圾回收器"><img src="/img/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="漫谈jvm垃圾回收机制及垃圾回收器"/></a><div class="content"><a class="title" href="/2021/11/13/%E6%BC%AB%E8%B0%88jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="漫谈jvm垃圾回收机制及垃圾回收器">漫谈jvm垃圾回收机制及垃圾回收器</a><time datetime="2021-11-13T12:00:41.000Z" title="发表于 2021-11-13 20:00:41">2021-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/04/ArrayList%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/" title="ArrayList源码详解"><img src="/img/7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ArrayList源码详解"/></a><div class="content"><a class="title" href="/2021/11/04/ArrayList%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/" title="ArrayList源码详解">ArrayList源码详解</a><time datetime="2021-11-04T13:16:29.000Z" title="发表于 2021-11-04 21:16:29">2021-11-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By slowsail</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>